{"file_contents":{"client/src/components/DrawingManager.css":{"content":".drawing-manager-container {\n  height: 100%;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n}\n\n.drawing-manager {\n  padding: 2rem;\n  height: 100%;\n  overflow-y: auto;\n}\n\n.drawing-mapper-header {\n  padding: 1rem 2rem;\n  background: white;\n  border-bottom: 2px solid #e0e0e0;\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n  flex-shrink: 0;\n}\n\n.drawing-mapper-header h2 {\n  font-size: 1.5rem;\n  color: #333;\n  margin: 0;\n}\n\n.back-to-list-btn {\n  padding: 0.5rem 1rem;\n  background: #f8f9fa;\n  color: #667eea;\n  border: 2px solid #e0e0e0;\n  border-radius: 6px;\n  font-weight: 500;\n  transition: all 0.2s;\n}\n\n.back-to-list-btn:hover {\n  background: #667eea;\n  color: white;\n  border-color: #667eea;\n}\n\n.drawing-header {\n  margin-bottom: 2rem;\n}\n\n.drawing-header h2 {\n  font-size: 1.75rem;\n  color: #333;\n  margin-bottom: 0.5rem;\n}\n\n.drawing-subtitle {\n  color: #666;\n  margin-bottom: 1.5rem;\n}\n\n.upload-drawing-btn {\n  padding: 0.75rem 1.5rem;\n  background: #667eea;\n  color: white;\n  border-radius: 8px;\n  font-weight: 500;\n  transition: all 0.2s;\n}\n\n.upload-drawing-btn:hover {\n  background: #5568d3;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);\n}\n\n.drawing-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n  gap: 1.5rem;\n}\n\n.no-drawings {\n  grid-column: 1 / -1;\n  padding: 3rem 1.5rem;\n  text-align: center;\n  color: #999;\n}\n\n.no-drawings .hint {\n  font-size: 0.875rem;\n  margin-top: 0.5rem;\n}\n\n.drawing-card {\n  background: white;\n  border: 2px solid #e0e0e0;\n  border-radius: 12px;\n  padding: 1.5rem;\n  cursor: pointer;\n  transition: all 0.2s;\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.drawing-card:hover {\n  border-color: #667eea;\n  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);\n  transform: translateY(-2px);\n}\n\n.drawing-card.selected {\n  border-color: #667eea;\n  background: #e8ebfa;\n}\n\n.drawing-preview {\n  width: 80px;\n  height: 80px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: #f8f9fa;\n  border-radius: 8px;\n  margin-bottom: 1rem;\n}\n\n.drawing-icon {\n  font-size: 2.5rem;\n}\n\n.drawing-info {\n  text-align: center;\n  width: 100%;\n}\n\n.drawing-name {\n  font-weight: 600;\n  color: #333;\n  margin-bottom: 0.5rem;\n  word-break: break-word;\n  font-size: 0.9rem;\n}\n\n.drawing-type {\n  font-size: 0.75rem;\n  color: #666;\n  text-transform: uppercase;\n  font-weight: 500;\n  margin-bottom: 0.5rem;\n}\n\n.drawing-mapped-badge {\n  display: inline-block;\n  padding: 0.25rem 0.5rem;\n  background: #d4f4dd;\n  color: #2d6a3e;\n  border-radius: 4px;\n  font-size: 0.75rem;\n  font-weight: 500;\n}\n\n.drawing-actions {\n  position: absolute;\n  top: 0.5rem;\n  right: 0.5rem;\n  display: flex;\n  gap: 0.25rem;\n  opacity: 0;\n  transition: opacity 0.2s;\n}\n\n.drawing-card:hover .drawing-actions {\n  opacity: 1;\n}\n\n.rename-drawing-btn,\n.delete-drawing-btn {\n  padding: 0.5rem;\n  background: rgba(255, 255, 255, 0.9);\n  font-size: 1rem;\n  transition: all 0.2s;\n  border-radius: 4px;\n  border: 1px solid #e0e0e0;\n}\n\n.rename-drawing-btn:hover {\n  background: #e8f4ff;\n  border-color: #667eea;\n  transform: scale(1.1);\n}\n\n.delete-drawing-btn:hover {\n  background: #fee;\n  border-color: #f44;\n  transform: scale(1.1);\n}\n","size_bytes":3273},"src/types.ts":{"content":"export interface FieldMapping {\n  x: number;\n  y: number;\n  size: number;\n  align?: 'left' | 'center' | 'right';\n  color?: string;\n  fontFamily?: 'Helvetica' | 'Helvetica-Bold' | 'Helvetica-Oblique' | 'Times-Roman' | 'Times-Bold' | 'Times-Italic' | 'Courier' | 'Courier-Bold';\n  maxWidth?: number;\n  maxHeight?: number;\n  bold?: boolean;\n  italic?: boolean;\n  condition?: {\n    field: string;\n    operator: 'equals' | 'not_equals' | 'contains' | 'not_contains';\n    value: string;\n  };\n}\n\nexport interface TemplateMapping {\n  [fieldName: string]: FieldMapping;\n}\n\nexport interface DrawingPlacementArea {\n  drawingName: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotation?: number;\n  conditionField?: string;\n  conditionValue?: string;\n}\n\nexport interface TemplateConfiguration {\n  mapping: TemplateMapping;\n  drawingPlacements?: DrawingPlacementArea[];\n}\n\nexport interface DrawingInfo {\n  name: string;\n  type: 'pdf' | 'image' | 'svg';\n  hasMapping: boolean;\n}\n\nexport interface DrawingInsertion {\n  drawing: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotation?: number;\n  data: {\n    [key: string]: string;\n  };\n}\n\nexport interface GenerateRequest {\n  template: string;\n  data: {\n    [key: string]: string;\n  };\n  drawings?: DrawingInsertion[];\n}\n\nexport interface TemplateInfo {\n  name: string;\n  hasMapping: boolean;\n}\n\nexport interface Combination {\n  name: string;\n  templateName: string;\n  drawingPlacements: DrawingPlacementArea[];\n}\n\nexport interface CombinationInfo {\n  name: string;\n}\n","size_bytes":1551},"replit.md":{"content":"# PDF Generator Microservice for Technical Drawings\n\n## Overview\nA TypeScript-based PDF Generator microservice for ERPNext/Frappe integration designed specifically for technical drawings and customer templates. This application allows you to:\n- Upload PDF templates with visual field mapping\n- Upload technical drawings (PDF, PNG, JPG, SVG) with field mappings\n- Define drawing placement areas in templates\n- Generate composite PDFs via REST API with template + drawing data\n- Support conditional field rendering\n- Full-screen visual editor with drag-to-define field areas\n- No database required - everything is file-based\n\n**Status**: Complete three-tier architecture implemented and ready for testing\n**Last Updated**: October 30, 2025 - Production-Ready Release v2\n\n## Recent Updates (October 30, 2025 - v3)\n\n### Major Layout & UX Improvements ‚úÖ\n**Problem Solved**: Combinations views were cramped with wasted horizontal space\n\n1. **Test/Preview Layout - 40% Wider Sidebar**\n   - Sidebar now uses 40% of screen width (was fixed 550px)\n   - Min-width: 550px, Max-width: 800px for flexibility\n   - Much better use of horizontal space\n   - Preview panel gets remaining 60% width\n   - No more cramped vertical scrolling!\n\n2. **Hide Sidebar Functionality** (NEW)\n   - Click \"‚úï Hide Sidebar\" button in combinations editor\n   - Sidebar smoothly collapses to give 100% width\n   - Click \"‚ò∞ Show Sidebar\" to restore\n   - Works in both Edit and Test/Preview modes\n   - Provides maximum space when needed\n\n3. **Larger, More Spacious Buttons & Controls**\n   - Edit/Test mode tabs: Larger padding (0.75rem √ó 1.5rem), bigger font (1rem)\n   - Save/Delete buttons: Bigger (0.875rem √ó 2rem), bolder (font-weight: 600)\n   - Better spacing between all action buttons (gap: 1rem)\n   - More professional, easier to click\n\n4. **Visual Placement Editor - More Vertical Space**\n   - Height: calc(100vh - 200px) from 280px = +80px\n   - Min-height: 600px from 500px = +100px\n   - Much more comfortable for positioning drawings\n\n5. **Drawing Rotation Support** ‚úÖ (NEW)\n   - Rotate drawings 0-360 degrees when placing on templates\n   - Rotation input in placement properties panel\n   - Visual preview shows rotation in real-time\n   - Backend applies center-based rotation (not corner-based)\n   - Rotation matrix compensates for pdf-lib's coordinate system\n   - Works for both PDF drawings and image drawings\n   - Generated PDFs match visual preview exactly\n\n6. **Realtime Drawing Preview** ‚úÖ (NEW)\n   - Shows actual drawing images/PDFs during placement (not just rectangles)\n   - Loads PDFs and images asynchronously in background\n   - Displays at 70% opacity for easy positioning\n   - Preview respects rotation settings\n   - Cached for performance\n   - Labels show rotation angle: \"1. HDR.pdf (90¬∞)\"\n\n7. **Improved Overall Proportions**\n   - Better balance between form inputs and preview areas\n   - Horizontal space properly utilized throughout\n   - Reduced vertical cramming\n   - Smoother, more professional appearance\n\n---\n\n## Recent Updates (October 30, 2025 - v2)\n\n### Production-Ready Improvements ‚úÖ\n1. **Combination Editor - Maximum Screen Space**\n   - Increased height to `calc(100vh - 200px)` (previously 280px offset)\n   - Increased min-height to 600px (previously 500px)\n   - Result: 80px more vertical space + much larger minimum height\n   - Editor now dominates the screen for comfortable positioning\n\n2. **Pan/Navigate Functionality - All PDF Viewers** (NEW)\n   - Middle-click (scroll wheel button) and drag to pan when zoomed\n   - Works in Templates, Drawings, and Combinations editors\n   - Smooth cursor changes: grab ‚Üí grabbing\n   - Pointer events disabled on overlay during pan for smooth scrolling\n   - Left-click reserved for drawing/selection (no conflicts)\n   - Perfect for navigating large PDFs at high zoom levels\n\n3. **Aspect Ratio Preservation - Backend** (FIXED)\n   - Drawings no longer get stretched or squished\n   - Backend calculates drawing vs placement aspect ratios\n   - Letterbox (horizontal bars) or pillarbox (vertical bars) as needed\n   - Drawings centered within placement areas\n   - Works for both PDF drawings and PNG/JPG images\n   - Professional, distortion-free output\n\n4. **Consistency Across All Viewers**\n   - Templates, Drawings, and Combinations all work identically\n   - Same zoom controls everywhere\n   - Same pan behavior everywhere\n   - Same scroll functionality everywhere\n   - Users learn once, use everywhere\n\n---\n\n## Recent Updates (October 30, 2025 - v1)\n\n### Latest Implementation ‚úÖ (Production-Ready Release)\n1. **Visual Drawing Placement Editor**\n   - Drag-to-position drawings directly on template preview\n   - Resize drawings via corner handles\n   - Click to select, shows properties panel\n   - Visual feedback with numbered labels and colored borders\n   - Zoom controls for precision positioning\n   - Real-time updates to combination configuration\n   - **Full viewport height** - uses `calc(100vh - 280px)` with no scrolling\n   - Centered canvas display with improved button styling\n\n2. **Conditional Drawing Rendering** (NEW)\n   - Show/hide drawings based on template field values\n   - Add condition to any drawing placement:\n     - **Field Name**: Template field to check (e.g., \"show_details\")\n     - **Required Value**: Value that must match (e.g., \"yes\")\n   - Empty condition = drawing always shows\n   - Backend automatically skips drawings when condition not met\n   - Perfect for optional technical details, annotations, or variants\n\n3. **Critical Data Synchronization Fix**\n   - Placements now properly sync with drawing mappings and data\n   - Auto-loads field mappings when new drawings added\n   - Removes stale entries when drawings deleted or changed\n   - Uses Promise.all for efficient parallel mapping fetches\n   - Preserves user input data when drawings persist\n   - Test mode shows only active drawing fields\n   - Generation receives clean payload with no stale data\n\n4. **UI/UX Polish & Production Ready**\n   - Fixed drawing mapper layout - no more distortion/shifting\n   - Consistent button styling across all views\n   - Improved zoom controls with better visibility\n   - All PDF viewers use full height with flexbox layout\n   - Canvas containers use `overflow: hidden` for crisp display\n   - Professional hover effects and transitions\n\n3. **Drawing Field Mapping UI**\n   - Reused PDFMapper component for both templates and drawings\n   - Added `isDrawing` prop to switch between template and drawing modes\n   - Only PDF drawings can have field mappings (images embedded directly)\n   - Integrated into DrawingManager with seamless navigation\n   - Separate API endpoints: `/api/drawing-mappings/` vs `/api/mappings/`\n\n4. **Drawing Rename Functionality**\n   - Rename drawings while preserving file extensions\n   - Automatically updates all combination references\n   - Template reusability across projects\n\n5. **Combinations Management**\n   - Three-tier architecture: Templates ‚Üí Drawings ‚Üí Combinations\n   - Combinations link templates with drawing placements\n   - Each placement defines: drawing name, x, y, width, height\n   - Edit/Test mode toggle for combination workflow\n   - File-based storage in `/combinations/` directory\n\n4. **PDF Compositing Engine**\n   - `generateWithCombination()` method in PDFService\n   - Loads combination configuration from file\n   - Applies template field mappings first\n   - For each drawing placement:\n     - Loads drawing file (PDF or image)\n     - Applies drawing field mappings (PDF only)\n     - Embeds filled drawing into template at specified position\n   - Supports PDF, PNG, JPG formats\n   - Proper coordinate conversion and scaling\n   - All font variants (bold, italic) working for both template and drawing fields\n\n5. **Combination-Based Generation API**\n   - POST `/api/generate-combination` endpoint\n   - Accepts: combination name, template data, drawings data\n   - Returns: Composite PDF with all fields filled and drawings placed\n   - Cache-control headers for fresh downloads\n\n### Completed Features ‚úÖ\n1. **Full-Screen UI Redesign**\n   - 100vh layout for maximum workspace\n   - Collapsible template sidebar for more viewing space\n   - Templates/Drawings main view tabs in header\n   - Compact header design\n\n2. **Template Management Enhancements**\n   - Delete template functionality with confirmation\n   - Delete button appears on hover over template items\n   - Automatic cleanup of template + mapping files\n\n3. **Visual Area Selection System**\n   - Drag rectangles on PDF to define field boundaries (width √ó height)\n   - Grid snapping (5-50px) for uniform field sizing\n   - Manual position/size inputs (x, y, width, height) with precision controls\n   - Real-time visual overlay showing field areas\n   - Fixed coordinate system alignment (baseline positioning)\n\n4. **Enhanced Font System**\n   - Bold + Italic font combinations with proper StandardFonts mapping\n   - Legacy compatibility for existing templates\n   - Font families: Helvetica, Times-Roman, Courier (with bold/italic variants)\n   - Text color picker and alignment controls\n\n5. **PDF Preview System**\n   - In-browser PDF preview before download\n   - Cache-control headers for instant updates\n   - Download button for final PDFs\n\n6. **Drawing Management System** (NEW)\n   - Upload drawings: PDF, PNG, JPG, GIF, SVG\n   - List all drawings with type badges\n   - Delete drawings with confirmation\n   - Separate API endpoints for drawing management\n   - File-based storage in `/drawings/` directory\n\n7. **Conditional Field Logic** (Schema Ready)\n   - Type definitions for conditional rendering\n   - Operators: equals, not_equals, contains, not_contains\n   - Backend ready, UI implementation pending\n\n### Pending Features üìã\n1. **Conditional Field UI**\n   - Add condition builder to field mapping interface\n   - Show/hide fields based on data values\n   - Visual indication of conditional fields\n\n2. **Multi-Drawing Template Support**\n   - UI for managing multiple drawing placements\n   - Drawing slot naming (e.g., \"Front View\", \"Side View\")\n   - Preview all drawing placements simultaneously\n\n## Project Architecture\n\n### Backend (TypeScript + Express)\n- **src/server.ts** - Express API server with CORS enabled\n- **src/pdfService.ts** - PDF manipulation and compositing service\n- **src/types.ts** - TypeScript type definitions (expanded for drawings)\n\n### Frontend (React + Vite)\n- **client/src/App.tsx** - Main app with Templates/Drawings views\n- **client/src/components/PDFMapper.tsx** - Visual template field mapper\n- **client/src/components/DrawingManager.tsx** - Drawing upload and management\n- **client/src/components/TemplateList.tsx** - Template sidebar with delete\n- **client/src/components/TestGenerator.tsx** - PDF generation tester\n\n### File Structure\n```\n/templates/           - PDF template files\n/mappings/            - JSON mapping files (template field positions)\n/drawings/            - Drawing files (PDF, PNG, JPG, SVG)\n/drawings_mappings/   - JSON mapping files (drawing field positions)\n/output/              - Temporary generated PDFs (optional)\n/dist/                - Compiled backend code\n/client/build/        - Built React frontend\n```\n\n## API Endpoints\n\n### Template Management\n- `GET /api/templates` - List all templates\n- `GET /api/templates/:name` - Download specific template\n- `POST /api/templates/upload` - Upload new template (multipart/form-data)\n- `DELETE /api/templates/:name` - Delete template and its mapping\n- `GET /api/mappings/:name` - Get field mapping for template\n- `POST /api/mappings/:name` - Save field mapping for template\n\n### Drawing Management\n- `GET /api/drawings` - List all drawings with type info\n- `GET /api/drawings/:name` - Download specific drawing\n- `POST /api/drawings/upload` - Upload new drawing (multipart/form-data)\n- `POST /api/drawings/:oldName/rename` - Rename drawing (updates all combinations)\n- `DELETE /api/drawings/:name` - Delete drawing and its mapping\n- `GET /api/drawing-mappings/:name` - Get field mapping for drawing\n- `POST /api/drawing-mappings/:name` - Save field mapping for drawing\n\n### Combinations Management\n- `GET /api/combinations` - List all combinations\n- `GET /api/combinations/:name` - Get specific combination configuration\n- `POST /api/combinations/:name` - Save combination (template + drawing placements)\n- `DELETE /api/combinations/:name` - Delete combination\n\n### PDF Generation\n- `POST /api/generate` - Generate filled PDF from template + data (legacy)\n- `POST /api/generate-combination` - Generate PDF using combination configuration\n\n## Type Definitions\n\n### FieldMapping (Enhanced)\n```typescript\ninterface FieldMapping {\n  x: number;\n  y: number;\n  size: number;\n  align?: 'left' | 'center' | 'right';\n  color?: string;\n  fontFamily?: string;\n  maxWidth?: number;\n  maxHeight?: number;\n  bold?: boolean;\n  italic?: boolean;\n  condition?: {\n    field: string;\n    operator: 'equals' | 'not_equals' | 'contains' | 'not_contains';\n    value: string;\n  };\n}\n```\n\n### DrawingPlacementArea\n```typescript\ninterface DrawingPlacementArea {\n  drawingName: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  conditionField?: string;\n  conditionValue?: string;\n}\n```\n\n### GenerateRequest (Enhanced)\n```typescript\ninterface GenerateRequest {\n  template: string;\n  data: { [key: string]: string };\n  drawings?: {\n    drawing: string;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    data: { [key: string]: string };\n  }[];\n}\n```\n\n## Mapping JSON Format\n\n### Template Mapping (with conditional fields)\n```json\n{\n  \"customer_name\": {\n    \"x\": 100,\n    \"y\": 200,\n    \"size\": 14,\n    \"align\": \"left\",\n    \"fontFamily\": \"Helvetica\",\n    \"bold\": true,\n    \"maxWidth\": 300,\n    \"maxHeight\": 20\n  },\n  \"special_note\": {\n    \"x\": 100,\n    \"y\": 250,\n    \"size\": 12,\n    \"condition\": {\n      \"field\": \"has_note\",\n      \"operator\": \"equals\",\n      \"value\": \"yes\"\n    }\n  }\n}\n```\n\n### Drawing Info Response\n```json\n{\n  \"name\": \"front_view.pdf\",\n  \"type\": \"pdf\",\n  \"hasMapping\": true\n}\n```\n\n## Three-Tier Technical Drawing Workflow\n\n### Tier 1: Templates\n1. Upload main template PDF (title block, borders, approval fields)\n2. Map template fields using visual drag-to-define interface\n3. Configure field styling: font, size, color, alignment, bold, italic\n4. Save template mapping\n\n### Tier 2: Drawings\n1. Upload technical drawings (PDF, PNG, JPG, SVG)\n2. For PDF drawings: Map fields (dimensions, part numbers, notes)\n3. For image drawings: No mapping needed (embedded directly)\n4. Save drawing mappings\n5. Optional: Rename drawings for template reusability\n\n### Tier 3: Combinations\n1. Create new combination\n2. Select base template\n3. Visual drawing placement:\n   - Template preview loads automatically\n   - Click \"Add Drawing\" to create placement rectangle\n   - Drag rectangle to position on template\n   - Resize using corner handle\n   - Select different drawing from dropdown\n   - Repeat for multiple drawings (front view, side view, etc.)\n   - Zoom in/out for precision\n4. Save combination configuration\n5. Switch to Test mode to fill data\n6. Generate composite PDF\n\n### Generate PDFs via API\n\n**Using Combinations (Recommended):**\n```javascript\nPOST /api/generate-combination\n{\n  \"combination\": \"my_combination\",\n  \"templateData\": {\n    \"date\": \"2025-10-30\",\n    \"author\": \"John Doe\",\n    \"customer\": \"Acme Corp\",\n    \"description\": \"Widget Assembly\"\n  },\n  \"drawingsData\": {\n    \"front_view.pdf\": {\n      \"dimension_a\": \"100mm\",\n      \"dimension_b\": \"50mm\",\n      \"part_number\": \"WID-001\"\n    },\n    \"side_view.png\": {}\n  }\n}\n```\n\n**Legacy Direct Generation:**\n```javascript\nPOST /api/generate\n{\n  \"template\": \"Customer_Drawing_Template.pdf\",\n  \"data\": {\n    \"date\": \"2025-10-30\",\n    \"author\": \"John Doe\"\n  },\n  \"drawings\": [\n    {\n      \"drawing\": \"front_view.pdf\",\n      \"x\": 50,\n      \"y\": 200,\n      \"width\": 400,\n      \"height\": 300,\n      \"data\": {\n        \"dimension_a\": \"100mm\"\n      }\n    }\n  ]\n}\n```\n\n## Features\n\n### ‚úÖ Completed\n- Full-screen visual field mapper with drag-to-define areas\n- Template upload and management\n- Template deletion\n- Field mapping with visual overlay\n- Grid snapping for uniform sizing\n- Manual position/size inputs\n- Font customization (family, size, bold, italic, color)\n- Text alignment (left, center, right)\n- Text wrapping and clipping within defined areas\n- PDF preview in browser\n- Drawing upload and management\n- Drawing deletion\n- Drawing rename with combination updates\n- Drawing field mapping UI (PDF only)\n- Combinations management system\n- **Visual drag-to-place drawing placement editor**\n- **Drag and resize drawings on template preview**\n- **Automatic drawing data synchronization**\n- **Edit/Test mode toggle for combinations**\n- PDF compositing engine with field mappings\n- Multiple drawings per combination\n- Combination-based PDF generation API\n- File-based storage (no database)\n- CORS enabled API\n- Type-safe TypeScript implementation\n- Collapsible sidebar for maximum workspace\n- Complete three-tier architecture (Templates ‚Üí Drawings ‚Üí Combinations)\n\n### üìã Planned\n- Conditional field rendering UI\n- Drawing preview in placement areas\n- Template + drawing preview mode\n- Batch PDF generation\n\n## Development\n\n### Install Dependencies\n```bash\nnpm install\ncd client && npm install\n```\n\n### Build\n```bash\nnpm run build           # Build backend\ncd client && npm run build  # Build frontend\n```\n\n### Run Development Server\n```bash\nnpm run dev\n```\n\nServer runs on http://0.0.0.0:5000\n- Admin interface: http://0.0.0.0:5000\n- API: http://0.0.0.0:5000/api/generate\n\n## User Workflow\n\n### Template Mode\n1. Click Templates tab\n2. Upload or select template\n3. Use Field Mapper to drag-define field areas\n4. Configure text styling (font, size, color, alignment)\n5. Save mapping\n6. Test with Test Generator\n\n### Drawings Mode\n1. Click Drawings tab\n2. Upload technical drawings (PDF, PNG, JPG, SVG)\n3. Select drawing to map fields (Coming soon)\n4. Define drawing-specific field mappings\n\n### Integration (Coming soon)\n1. Define drawing placement areas in template\n2. Generate composite PDFs via API\n3. Single JSON payload with template data + drawing data\n\n## Technical Details\n\n- **Backend**: Node.js 20+, Express, TypeScript\n- **PDF Library**: pdf-lib (pure JS, no dependencies)\n- **Frontend**: React 18, Vite, PDF.js\n- **File Management**: fs-extra\n- **Upload Handling**: Multer\n- **Coordinate System**: PDF points (72 points = 1 inch), Y-axis flipped\n\n## Security\n\n- Path traversal protection with filename sanitization\n- Allowed file types validation\n- CORS configuration for production deployment\n- No secret exposure in client code\n\n## Design Decisions\n\n### File-Based Storage\n- No database dependency for simplicity\n- Easy backup and version control\n- Direct file manipulation\n- Suitable for moderate volume (hundreds of templates)\n\n### Coordinate Storage\n- Stored as top-edge Y for UI consistency\n- Converted to baseline Y for PDF rendering\n- Automatic height calculation for text baseline\n\n### Font System\n- Base families with bold/italic flags\n- Backend handles all font variant combinations\n- Supports legacy templates with direct font names\n\n## Next Steps\n\n1. **Complete Drawing Integration**\n   - Implement drawing field mapper UI (reuse PDFMapper)\n   - Add drawing placement area definition in templates\n   - Build PDF compositing logic\n\n2. **Enhanced Features**\n   - Conditional field rendering UI\n   - Multi-drawing template support\n   - Drawing preview in placements\n\n3. **Production Readiness**\n   - Error handling improvements\n   - Validation enhancements\n   - Performance optimization for large files\n   - Deployment configuration\n","size_bytes":19622},"client/src/components/TestGenerator.css":{"content":".test-generator {\n  padding: 0;\n  height: calc(100vh - 200px);\n}\n\n.test-layout {\n  display: flex;\n  height: 100%;\n}\n\n.test-sidebar {\n  width: 400px;\n  border-right: 1px solid #e0e0e0;\n  display: flex;\n  flex-direction: column;\n  overflow-y: auto;\n  background: white;\n}\n\n.test-header {\n  padding: 1.5rem;\n  border-bottom: 1px solid #e0e0e0;\n  background: #fafafa;\n}\n\n.test-header h3 {\n  margin: 0 0 0.5rem 0;\n  color: #333;\n  font-size: 1.2rem;\n}\n\n.test-header p {\n  margin: 0;\n  color: #666;\n  font-size: 0.9rem;\n}\n\n.test-form {\n  flex: 1;\n  padding: 1.5rem;\n  overflow-y: auto;\n}\n\n.form-group {\n  margin-bottom: 1.25rem;\n}\n\n.form-group label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n  color: #444;\n  font-size: 0.95rem;\n}\n\n.form-group input {\n  width: 100%;\n  padding: 0.625rem;\n  border: 1px solid #ddd;\n  border-radius: 6px;\n  font-size: 0.95rem;\n  transition: border-color 0.2s;\n}\n\n.form-group input:focus {\n  outline: none;\n  border-color: #667eea;\n  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);\n}\n\n.test-actions {\n  padding: 1.5rem;\n  border-top: 1px solid #e0e0e0;\n  display: flex;\n  flex-direction: column;\n  gap: 0.75rem;\n  background: #fafafa;\n}\n\n.generate-btn,\n.download-btn {\n  width: 100%;\n  padding: 0.875rem;\n  font-weight: 500;\n  font-size: 1rem;\n  border-radius: 8px;\n  transition: all 0.2s;\n  cursor: pointer;\n}\n\n.generate-btn {\n  background: #667eea;\n  color: white;\n}\n\n.generate-btn:hover:not(:disabled) {\n  background: #5568d3;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);\n}\n\n.generate-btn:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n\n.download-btn {\n  background: #28a745;\n  color: white;\n}\n\n.download-btn:hover {\n  background: #218838;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);\n}\n\n.test-preview {\n  flex: 1;\n  background: #2a2a2a;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.pdf-preview-container {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n\n.preview-header {\n  padding: 1rem 1.5rem;\n  background: rgba(255, 255, 255, 0.1);\n  border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.preview-header h4 {\n  margin: 0;\n  color: white;\n  font-size: 1.1rem;\n}\n\n.pdf-preview-frame {\n  flex: 1;\n  width: 100%;\n  border: none;\n  background: white;\n}\n\n.no-preview {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.no-preview-content {\n  text-align: center;\n  padding: 3rem;\n}\n\n.preview-icon {\n  font-size: 4rem;\n  display: block;\n  margin-bottom: 1rem;\n  opacity: 0.3;\n}\n\n.no-preview-content h3 {\n  color: rgba(255, 255, 255, 0.9);\n  margin: 0 0 0.5rem 0;\n  font-size: 1.5rem;\n}\n\n.no-preview-content p {\n  color: rgba(255, 255, 255, 0.6);\n  font-size: 1rem;\n  margin: 0;\n}\n\n.no-mapping {\n  padding: 3rem;\n  text-align: center;\n}\n\n.no-mapping h3 {\n  color: #333;\n  margin-bottom: 0.5rem;\n}\n\n.no-mapping p {\n  color: #666;\n}\n","size_bytes":2933},"client/vite.config.ts":{"content":"import { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  build: {\n    outDir: 'build',\n  },\n  server: {\n    host: '0.0.0.0',\n    port: 3000,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:5000',\n        changeOrigin: true,\n      },\n    },\n  },\n});\n","size_bytes":341},"client/src/components/VisualPlacementEditor.tsx":{"content":"import { useState, useEffect, useRef } from 'react';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport './VisualPlacementEditor.css';\n\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\n\ninterface DrawingPlacement {\n  drawingName: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotation?: number;\n  conditionField?: string;\n  conditionValue?: string;\n}\n\ninterface Props {\n  templateName: string;\n  placements: DrawingPlacement[];\n  onPlacementsChange: (placements: DrawingPlacement[]) => void;\n  drawings: string[];\n}\n\nfunction VisualPlacementEditor({ templateName, placements, onPlacementsChange, drawings }: Props) {\n  const [zoom, setZoom] = useState(1.0);\n  const [selectedIndex, setSelectedIndex] = useState<number | null>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [isResizing, setIsResizing] = useState(false);\n  const [dragStart, setDragStart] = useState<{ x: number; y: number } | null>(null);\n  const [isPanning, setIsPanning] = useState(false);\n  const [panStart, setPanStart] = useState<{ x: number; y: number; scrollLeft: number; scrollTop: number } | null>(null);\n  const [drawingPreviews, setDrawingPreviews] = useState<{ [name: string]: HTMLImageElement | HTMLCanvasElement }>({});\n  \n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const overlayCanvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    loadPDF();\n  }, [templateName, zoom]);\n\n  useEffect(() => {\n    drawPlacements();\n  }, [placements, zoom, selectedIndex, drawingPreviews]);\n\n  useEffect(() => {\n    loadDrawingPreviews();\n  }, [placements]);\n\n  const loadPDF = async () => {\n    if (!canvasRef.current) return;\n\n    try {\n      const pdf = await pdfjsLib.getDocument(`/api/templates/${templateName}`).promise;\n      const page = await pdf.getPage(1);\n      \n      const viewport = page.getViewport({ scale: zoom });\n      const canvas = canvasRef.current;\n      const context = canvas.getContext('2d');\n      \n      if (!context) return;\n\n      canvas.width = viewport.width;\n      canvas.height = viewport.height;\n\n      if (overlayCanvasRef.current) {\n        overlayCanvasRef.current.width = viewport.width;\n        overlayCanvasRef.current.height = viewport.height;\n      }\n\n      await page.render({\n        canvasContext: context,\n        viewport: viewport,\n      }).promise;\n\n      drawPlacements();\n    } catch (error) {\n      console.error('Failed to load PDF:', error);\n    }\n  };\n\n  const loadDrawingPreviews = async () => {\n    const newPreviews: { [name: string]: HTMLImageElement | HTMLCanvasElement } = { ...drawingPreviews };\n    \n    for (const placement of placements) {\n      if (!newPreviews[placement.drawingName]) {\n        try {\n          const drawingFile = drawings.find(d => d === placement.drawingName);\n          if (!drawingFile) continue;\n\n          if (drawingFile.toLowerCase().endsWith('.pdf')) {\n            const pdf = await pdfjsLib.getDocument(`/api/drawings/${drawingFile}`).promise;\n            const page = await pdf.getPage(1);\n            const viewport = page.getViewport({ scale: 0.5 });\n            \n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = viewport.width;\n            tempCanvas.height = viewport.height;\n            const tempCtx = tempCanvas.getContext('2d');\n            if (tempCtx) {\n              await page.render({ canvasContext: tempCtx, viewport }).promise;\n              newPreviews[placement.drawingName] = tempCanvas;\n            }\n          } else {\n            const img = new Image();\n            img.crossOrigin = 'anonymous';\n            await new Promise((resolve, reject) => {\n              img.onload = resolve;\n              img.onerror = reject;\n              img.src = `/api/drawings/${drawingFile}`;\n            });\n            newPreviews[placement.drawingName] = img;\n          }\n        } catch (error) {\n          console.error(`Failed to load preview for ${placement.drawingName}:`, error);\n        }\n      }\n    }\n    \n    setDrawingPreviews(newPreviews);\n  };\n\n  const drawPlacements = () => {\n    const canvas = overlayCanvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    placements.forEach((placement, index) => {\n      const x = placement.x * zoom;\n      const y = placement.y * zoom;\n      const width = placement.width * zoom;\n      const height = placement.height * zoom;\n      const rotation = placement.rotation || 0;\n\n      const isSelected = index === selectedIndex;\n\n      ctx.save();\n      \n      const centerX = x + width / 2;\n      const centerY = y + height / 2;\n      ctx.translate(centerX, centerY);\n      ctx.rotate((rotation * Math.PI) / 180);\n      ctx.translate(-centerX, -centerY);\n\n      const preview = drawingPreviews[placement.drawingName];\n      if (preview) {\n        ctx.globalAlpha = 0.7;\n        ctx.drawImage(preview, x, y, width, height);\n        ctx.globalAlpha = 1.0;\n      } else {\n        ctx.fillStyle = isSelected ? 'rgba(102, 126, 234, 0.2)' : 'rgba(40, 167, 69, 0.15)';\n        ctx.fillRect(x, y, width, height);\n      }\n\n      ctx.strokeStyle = isSelected ? '#667eea' : '#28a745';\n      ctx.lineWidth = isSelected ? 3 : 2;\n      ctx.setLineDash(isSelected ? [] : [5, 5]);\n      ctx.strokeRect(x, y, width, height);\n      ctx.setLineDash([]);\n\n      ctx.restore();\n\n      ctx.fillStyle = isSelected ? '#667eea' : '#28a745';\n      ctx.font = `bold ${14}px Arial`;\n      const label = `${index + 1}. ${placement.drawingName}${rotation ? ` (${rotation}¬∞)` : ''}`;\n      const textMetrics = ctx.measureText(label);\n      \n      ctx.fillRect(x, y - 25, textMetrics.width + 16, 25);\n      ctx.fillStyle = 'white';\n      ctx.fillText(label, x + 8, y - 7);\n\n      if (isSelected) {\n        const handleSize = 8;\n        ctx.fillStyle = '#667eea';\n        ctx.fillRect(x + width - handleSize, y + height - handleSize, handleSize, handleSize);\n        ctx.strokeStyle = 'white';\n        ctx.lineWidth = 1;\n        ctx.strokeRect(x + width - handleSize, y + height - handleSize, handleSize, handleSize);\n      }\n    });\n  };\n\n  const handleCanvasMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (e.button === 1) {\n      return;\n    }\n    \n    const canvas = overlayCanvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const mouseX = (e.clientX - rect.left) / zoom;\n    const mouseY = (e.clientY - rect.top) / zoom;\n\n    for (let i = placements.length - 1; i >= 0; i--) {\n      const p = placements[i];\n      \n      const handleSize = 8 / zoom;\n      if (\n        mouseX >= p.x + p.width - handleSize &&\n        mouseX <= p.x + p.width &&\n        mouseY >= p.y + p.height - handleSize &&\n        mouseY <= p.y + p.height\n      ) {\n        setSelectedIndex(i);\n        setIsResizing(true);\n        setDragStart({ x: mouseX, y: mouseY });\n        return;\n      }\n\n      if (\n        mouseX >= p.x &&\n        mouseX <= p.x + p.width &&\n        mouseY >= p.y &&\n        mouseY <= p.y + p.height\n      ) {\n        setSelectedIndex(i);\n        setIsDragging(true);\n        setDragStart({ x: mouseX - p.x, y: mouseY - p.y });\n        return;\n      }\n    }\n\n    setSelectedIndex(null);\n  };\n\n  const handleCanvasMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!isDragging && !isResizing) return;\n    if (selectedIndex === null || !dragStart) return;\n\n    const canvas = overlayCanvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const mouseX = (e.clientX - rect.left) / zoom;\n    const mouseY = (e.clientY - rect.top) / zoom;\n\n    const newPlacements = [...placements];\n    const placement = newPlacements[selectedIndex];\n\n    if (isDragging) {\n      placement.x = Math.max(0, mouseX - dragStart.x);\n      placement.y = Math.max(0, mouseY - dragStart.y);\n    } else if (isResizing) {\n      placement.width = Math.max(50, mouseX - placement.x);\n      placement.height = Math.max(50, mouseY - placement.y);\n    }\n\n    onPlacementsChange(newPlacements);\n  };\n\n  const handleCanvasMouseUp = () => {\n    setIsDragging(false);\n    setIsResizing(false);\n    setDragStart(null);\n  };\n\n  const handleAddPlacement = () => {\n    if (drawings.length === 0) {\n      alert('No drawings available. Please upload drawings first.');\n      return;\n    }\n\n    const newPlacement: DrawingPlacement = {\n      drawingName: drawings[0],\n      x: 50,\n      y: 50,\n      width: 300,\n      height: 200\n    };\n\n    onPlacementsChange([...placements, newPlacement]);\n    setSelectedIndex(placements.length);\n  };\n\n  const handleRemovePlacement = () => {\n    if (selectedIndex === null) return;\n\n    const newPlacements = placements.filter((_, i) => i !== selectedIndex);\n    onPlacementsChange(newPlacements);\n    setSelectedIndex(null);\n  };\n\n  const handleUpdateSelectedPlacement = (field: keyof DrawingPlacement, value: string | number) => {\n    if (selectedIndex === null) return;\n\n    const newPlacements = [...placements];\n    newPlacements[selectedIndex] = {\n      ...newPlacements[selectedIndex],\n      [field]: value\n    };\n\n    onPlacementsChange(newPlacements);\n  };\n\n  const handleContainerMouseDown = (e: React.MouseEvent) => {\n    if (e.button === 2 || !containerRef.current) return;\n    \n    if (e.button === 1) {\n      const container = containerRef.current;\n      setIsPanning(true);\n      setPanStart({\n        x: e.clientX,\n        y: e.clientY,\n        scrollLeft: container.scrollLeft,\n        scrollTop: container.scrollTop\n      });\n      e.preventDefault();\n    }\n  };\n\n  const handleContainerMouseMove = (e: React.MouseEvent) => {\n    if (!isPanning || !panStart || !containerRef.current) return;\n\n    const dx = e.clientX - panStart.x;\n    const dy = e.clientY - panStart.y;\n    \n    containerRef.current.scrollLeft = panStart.scrollLeft - dx;\n    containerRef.current.scrollTop = panStart.scrollTop - dy;\n  };\n\n  const handleContainerMouseUp = () => {\n    setIsPanning(false);\n    setPanStart(null);\n  };\n\n  return (\n    <div className=\"visual-placement-editor\">\n      <div className=\"placement-toolbar\">\n        <div className=\"toolbar-left\">\n          <button className=\"toolbar-btn\" onClick={handleAddPlacement}>\n            ‚ûï Add Drawing\n          </button>\n          {selectedIndex !== null && (\n            <button className=\"toolbar-btn danger\" onClick={handleRemovePlacement}>\n              üóëÔ∏è Remove Selected\n            </button>\n          )}\n        </div>\n        \n        <div className=\"zoom-controls\">\n          <label>Zoom:</label>\n          <button onClick={() => setZoom(Math.max(0.5, zoom - 0.1))}>‚àí</button>\n          <span>{Math.round(zoom * 100)}%</span>\n          <button onClick={() => setZoom(Math.min(2, zoom + 0.1))}>+</button>\n        </div>\n      </div>\n\n      {selectedIndex !== null && (\n        <div className=\"placement-properties\">\n          <h4>Selected: {placements[selectedIndex].drawingName}</h4>\n          <div className=\"properties-grid\">\n            <div className=\"prop-field\">\n              <label>Drawing:</label>\n              <select\n                value={placements[selectedIndex].drawingName}\n                onChange={(e) => handleUpdateSelectedPlacement('drawingName', e.target.value)}\n              >\n                {drawings.map((drawing) => (\n                  <option key={drawing} value={drawing}>{drawing}</option>\n                ))}\n              </select>\n            </div>\n            <div className=\"prop-field\">\n              <label>X:</label>\n              <input\n                type=\"number\"\n                value={Math.round(placements[selectedIndex].x)}\n                onChange={(e) => handleUpdateSelectedPlacement('x', parseFloat(e.target.value))}\n              />\n            </div>\n            <div className=\"prop-field\">\n              <label>Y:</label>\n              <input\n                type=\"number\"\n                value={Math.round(placements[selectedIndex].y)}\n                onChange={(e) => handleUpdateSelectedPlacement('y', parseFloat(e.target.value))}\n              />\n            </div>\n            <div className=\"prop-field\">\n              <label>Width:</label>\n              <input\n                type=\"number\"\n                value={Math.round(placements[selectedIndex].width)}\n                onChange={(e) => handleUpdateSelectedPlacement('width', parseFloat(e.target.value))}\n              />\n            </div>\n            <div className=\"prop-field\">\n              <label>Height:</label>\n              <input\n                type=\"number\"\n                value={Math.round(placements[selectedIndex].height)}\n                onChange={(e) => handleUpdateSelectedPlacement('height', parseFloat(e.target.value))}\n              />\n            </div>\n            <div className=\"prop-field\">\n              <label>Rotation:</label>\n              <input\n                type=\"number\"\n                min=\"0\"\n                max=\"360\"\n                step=\"1\"\n                placeholder=\"0¬∞\"\n                value={placements[selectedIndex].rotation || 0}\n                onChange={(e) => handleUpdateSelectedPlacement('rotation', parseFloat(e.target.value) || 0)}\n              />\n              <span style={{ fontSize: '0.85rem', color: '#888' }}>degrees</span>\n            </div>\n          </div>\n          <div style={{ marginTop: '1rem', paddingTop: '1rem', borderTop: '1px solid #e0e0e0' }}>\n            <h4 style={{ fontSize: '0.95rem', marginBottom: '0.75rem', color: '#666' }}>Conditional Rendering (Optional)</h4>\n            <p style={{ fontSize: '0.85rem', color: '#888', marginBottom: '0.75rem' }}>\n              Show this drawing only when a specific field has a value. Leave empty to always show.\n            </p>\n            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.75rem' }}>\n              <div className=\"prop-field\">\n                <label>Field Name:</label>\n                <input\n                  type=\"text\"\n                  placeholder=\"e.g., show_detail\"\n                  value={placements[selectedIndex].conditionField || ''}\n                  onChange={(e) => handleUpdateSelectedPlacement('conditionField', e.target.value)}\n                />\n              </div>\n              <div className=\"prop-field\">\n                <label>Required Value:</label>\n                <input\n                  type=\"text\"\n                  placeholder=\"e.g., yes\"\n                  value={placements[selectedIndex].conditionValue || ''}\n                  onChange={(e) => handleUpdateSelectedPlacement('conditionValue', e.target.value)}\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n      )}\n\n      <div \n        ref={containerRef}\n        className={`canvas-container ${isPanning ? 'panning' : ''}`}\n        onMouseDown={handleContainerMouseDown}\n        onMouseMove={handleContainerMouseMove}\n        onMouseUp={handleContainerMouseUp}\n        onMouseLeave={handleContainerMouseUp}\n      >\n        <div className=\"canvas-wrapper\">\n          <canvas ref={canvasRef} className=\"pdf-canvas\" />\n          <canvas\n            ref={overlayCanvasRef}\n            className=\"overlay-canvas\"\n            onMouseDown={handleCanvasMouseDown}\n            onMouseMove={handleCanvasMouseMove}\n            onMouseUp={handleCanvasMouseUp}\n            onMouseLeave={handleCanvasMouseUp}\n          />\n        </div>\n      </div>\n\n      <div className=\"placement-help\">\n        <p>üí° <strong>Tip:</strong> Click and drag to position drawings. Middle-click to pan. Use corner handle to resize. Set rotation angle in properties panel.</p>\n      </div>\n    </div>\n  );\n}\n\nexport default VisualPlacementEditor;\n","size_bytes":15859},"client/src/components/PDFMapper.tsx":{"content":"import { useState, useEffect, useRef } from 'react';\nimport * as pdfjsLib from 'pdfjs-dist';\nimport './PDFMapper.css';\n\npdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;\n\ninterface FieldMapping {\n  x: number;\n  y: number;\n  size: number;\n  align?: 'left' | 'center' | 'right';\n  color?: string;\n  fontFamily?: string;\n  maxWidth?: number;\n  maxHeight?: number;\n  bold?: boolean;\n  italic?: boolean;\n}\n\ninterface TemplateMapping {\n  [fieldName: string]: FieldMapping;\n}\n\ninterface Props {\n  templateName: string;\n  onMappingSaved: () => void;\n  isDrawing?: boolean;\n}\n\nfunction PDFMapper({ templateName, onMappingSaved, isDrawing = false }: Props) {\n  const [mapping, setMapping] = useState<TemplateMapping>({});\n  const [editingField, setEditingField] = useState<string | null>(null);\n  const [newFieldName, setNewFieldName] = useState('');\n  const [fontSize, setFontSize] = useState(12);\n  const [alignment, setAlignment] = useState<'left' | 'center' | 'right'>('left');\n  const [textColor, setTextColor] = useState('#000000');\n  const [fontFamily, setFontFamily] = useState('Helvetica');\n  const [bold, setBold] = useState(false);\n  const [italic, setItalic] = useState(false);\n  const [zoom, setZoom] = useState(1.5);\n  const [isDrawingRect, setIsDrawingRect] = useState(false);\n  const [startPos, setStartPos] = useState<{ x: number; y: number } | null>(null);\n  const [currentRect, setCurrentRect] = useState<{ x: number; y: number; width: number; height: number } | null>(null);\n  const [manualX, setManualX] = useState(0);\n  const [manualY, setManualY] = useState(0);\n  const [manualWidth, setManualWidth] = useState(200);\n  const [manualHeight, setManualHeight] = useState(40);\n  const [snapToGrid, setSnapToGrid] = useState(false);\n  const [gridSize, setGridSize] = useState(10);\n  const [isPanning, setIsPanning] = useState(false);\n  const [panStart, setPanStart] = useState<{ x: number; y: number; scrollLeft: number; scrollTop: number } | null>(null);\n  \n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const overlayCanvasRef = useRef<HTMLCanvasElement>(null);\n  const viewerRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    setMapping({});\n    setEditingField(null);\n    setNewFieldName('');\n    setCurrentRect(null);\n    setIsDrawingRect(false);\n    setStartPos(null);\n    loadMapping();\n    loadPDF();\n  }, [templateName]);\n\n  useEffect(() => {\n    loadPDF();\n  }, [zoom]);\n\n  useEffect(() => {\n    drawFieldBoxes();\n  }, [mapping, zoom, currentRect]);\n\n  const loadMapping = async () => {\n    try {\n      const endpoint = isDrawing ? `/api/drawing-mappings/${templateName}` : `/api/mappings/${templateName}`;\n      const response = await fetch(endpoint);\n      if (response.ok) {\n        const data = await response.json();\n        setMapping(data);\n      } else {\n        setMapping({});\n      }\n    } catch (error) {\n      setMapping({});\n    }\n  };\n\n  const loadPDF = async () => {\n    const url = isDrawing ? `/api/drawings/${templateName}` : `/api/templates/${templateName}`;\n\n    try {\n      const loadingTask = pdfjsLib.getDocument(url);\n      const pdf = await loadingTask.promise;\n      const page = await pdf.getPage(1);\n\n      const canvas = canvasRef.current;\n      const overlayCanvas = overlayCanvasRef.current;\n      if (!canvas || !overlayCanvas) return;\n\n      const viewport = page.getViewport({ scale: zoom });\n      const context = canvas.getContext('2d');\n      if (!context) return;\n\n      canvas.width = viewport.width;\n      canvas.height = viewport.height;\n      overlayCanvas.width = viewport.width;\n      overlayCanvas.height = viewport.height;\n\n      await page.render({\n        canvasContext: context,\n        viewport: viewport,\n      }).promise;\n\n      drawFieldBoxes();\n    } catch (error) {\n      console.error('Error loading PDF:', error);\n    }\n  };\n\n  const drawFieldBoxes = () => {\n    const overlayCanvas = overlayCanvasRef.current;\n    if (!overlayCanvas) return;\n\n    const ctx = overlayCanvas.getContext('2d');\n    if (!ctx) return;\n\n    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);\n\n    Object.entries(mapping).forEach(([fieldName, field]) => {\n      const x = field.x * zoom;\n      const topY = field.y * zoom;\n      const boxWidth = (field.maxWidth || 200) * zoom;\n      const boxHeight = (field.maxHeight || field.size + 4) * zoom;\n      const baselineY = topY + (field.size * zoom);\n\n      const isEditing = editingField === fieldName;\n\n      ctx.strokeStyle = isEditing ? '#f59e0b' : '#667eea';\n      ctx.lineWidth = isEditing ? 3 : 2;\n      ctx.setLineDash([5, 5]);\n      ctx.strokeRect(x, topY, boxWidth, boxHeight);\n\n      ctx.fillStyle = isEditing ? 'rgba(245, 158, 11, 0.15)' : 'rgba(102, 126, 234, 0.1)';\n      ctx.fillRect(x, topY, boxWidth, boxHeight);\n\n      ctx.fillStyle = isEditing ? '#f59e0b' : '#667eea';\n      ctx.font = 'bold 12px Arial';\n      ctx.setLineDash([]);\n      ctx.fillText(fieldName, x, topY - 5);\n\n      ctx.beginPath();\n      ctx.arc(x, baselineY, 4, 0, 2 * Math.PI);\n      ctx.fillStyle = isEditing ? '#f59e0b' : '#ff4444';\n      ctx.fill();\n    });\n\n    if (currentRect) {\n      ctx.strokeStyle = '#10b981';\n      ctx.lineWidth = 2;\n      ctx.setLineDash([5, 5]);\n      ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);\n\n      ctx.fillStyle = 'rgba(16, 185, 129, 0.15)';\n      ctx.fillRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);\n    }\n  };\n\n  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (e.button === 1) {\n      return;\n    }\n    \n    if (!newFieldName.trim() && !editingField) {\n      alert('Please enter a field name first');\n      return;\n    }\n\n    const canvas = overlayCanvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const scaleX = canvas.width / rect.width;\n    const scaleY = canvas.height / rect.height;\n\n    const canvasX = (e.clientX - rect.left) * scaleX;\n    const canvasY = (e.clientY - rect.top) * scaleY;\n\n    setIsDrawingRect(true);\n    setStartPos({ x: canvasX, y: canvasY });\n    setCurrentRect({ x: canvasX, y: canvasY, width: 0, height: 0 });\n  };\n\n  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!isDrawingRect || !startPos) return;\n\n    const canvas = overlayCanvasRef.current;\n    if (!canvas) return;\n\n    const rect = canvas.getBoundingClientRect();\n    const scaleX = canvas.width / rect.width;\n    const scaleY = canvas.height / rect.height;\n\n    const canvasX = (e.clientX - rect.left) * scaleX;\n    const canvasY = (e.clientY - rect.top) * scaleY;\n\n    const width = canvasX - startPos.x;\n    const height = canvasY - startPos.y;\n\n    setCurrentRect({\n      x: width < 0 ? canvasX : startPos.x,\n      y: height < 0 ? canvasY : startPos.y,\n      width: Math.abs(width),\n      height: Math.abs(height),\n    });\n\n    drawFieldBoxes();\n  };\n\n  const snapToGridValue = (value: number): number => {\n    if (!snapToGrid) return Math.round(value);\n    return Math.round(value / gridSize) * gridSize;\n  };\n\n  const handleMouseUp = () => {\n    if (!isDrawingRect || !currentRect || !startPos) return;\n\n    let actualX = Math.round(currentRect.x / zoom);\n    let actualY = Math.round(currentRect.y / zoom);\n    let actualWidth = Math.round(currentRect.width / zoom);\n    let actualHeight = Math.round(currentRect.height / zoom);\n\n    if (snapToGrid) {\n      actualX = snapToGridValue(actualX);\n      actualY = snapToGridValue(actualY);\n      actualWidth = snapToGridValue(actualWidth);\n      actualHeight = snapToGridValue(actualHeight);\n    }\n\n    if (actualWidth < 10 || actualHeight < 5) {\n      alert('Area too small. Please draw a larger selection area.');\n      setIsDrawingRect(false);\n      setStartPos(null);\n      setCurrentRect(null);\n      drawFieldBoxes();\n      return;\n    }\n\n    setManualX(actualX);\n    setManualY(actualY);\n    setManualWidth(actualWidth);\n    setManualHeight(actualHeight);\n\n    applyFieldMapping(actualX, actualY, actualWidth, actualHeight);\n  };\n\n  const applyFieldMapping = (x: number, y: number, width: number, height: number) => {\n    const targetFieldName = editingField || newFieldName;\n    \n    if (!targetFieldName.trim()) {\n      alert('Please enter a field name first');\n      return;\n    }\n\n    const newMapping = {\n      ...mapping,\n      [targetFieldName]: {\n        x: x,\n        y: y,\n        size: fontSize,\n        align: alignment,\n        color: textColor,\n        fontFamily: fontFamily,\n        maxWidth: width,\n        maxHeight: height,\n        bold: bold,\n        italic: italic,\n      },\n    };\n\n    setMapping(newMapping);\n    if (!editingField) {\n      setNewFieldName('');\n    }\n    setEditingField(null);\n    setIsDrawingRect(false);\n    setStartPos(null);\n    setCurrentRect(null);\n  };\n\n  const handleManualApply = () => {\n    const x = snapToGridValue(manualX);\n    const y = snapToGridValue(manualY);\n    const width = snapToGridValue(manualWidth);\n    const height = snapToGridValue(manualHeight);\n\n    applyFieldMapping(x, y, width, height);\n  };\n\n  const handleSaveMapping = async () => {\n    try {\n      const endpoint = isDrawing ? `/api/drawing-mappings/${templateName}` : `/api/mappings/${templateName}`;\n      const response = await fetch(endpoint, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(mapping),\n      });\n\n      if (response.ok) {\n        alert('Mapping saved successfully!');\n        onMappingSaved();\n      } else {\n        alert('Failed to save mapping');\n      }\n    } catch (error) {\n      console.error('Save error:', error);\n      alert('Failed to save mapping');\n    }\n  };\n\n  const handleDeleteField = (fieldName: string) => {\n    const newMapping = { ...mapping };\n    delete newMapping[fieldName];\n    setMapping(newMapping);\n    if (editingField === fieldName) {\n      setEditingField(null);\n    }\n  };\n\n  const handleEditField = (fieldName: string) => {\n    const field = mapping[fieldName];\n    setEditingField(fieldName);\n    setFontSize(field.size);\n    setAlignment(field.align || 'left');\n    setTextColor(field.color || '#000000');\n    setFontFamily(field.fontFamily || 'Helvetica');\n    setBold(field.bold || false);\n    setItalic(field.italic || false);\n    \n    setManualX(field.x);\n    setManualY(field.y);\n    setManualWidth(field.maxWidth || 200);\n    setManualHeight(field.maxHeight || (field.size + 4));\n  };\n\n  const handleCancelEdit = () => {\n    setEditingField(null);\n    setFontSize(12);\n    setAlignment('left');\n    setTextColor('#000000');\n    setFontFamily('Helvetica');\n    setBold(false);\n    setItalic(false);\n  };\n\n  const handleViewerMouseDown = (e: React.MouseEvent) => {\n    if (e.button === 2 || !viewerRef.current) return;\n    \n    if (e.button === 1) {\n      const viewer = viewerRef.current;\n      setIsPanning(true);\n      setPanStart({\n        x: e.clientX,\n        y: e.clientY,\n        scrollLeft: viewer.scrollLeft,\n        scrollTop: viewer.scrollTop\n      });\n      e.preventDefault();\n    }\n  };\n\n  const handleViewerMouseMove = (e: React.MouseEvent) => {\n    if (!isPanning || !panStart || !viewerRef.current) return;\n\n    const dx = e.clientX - panStart.x;\n    const dy = e.clientY - panStart.y;\n    \n    viewerRef.current.scrollLeft = panStart.scrollLeft - dx;\n    viewerRef.current.scrollTop = panStart.scrollTop - dy;\n  };\n\n  const handleViewerMouseUp = () => {\n    setIsPanning(false);\n    setPanStart(null);\n  };\n\n  return (\n    <div className=\"pdf-mapper\">\n      <div className=\"mapper-content\">\n        <div \n          ref={viewerRef}\n          className={`pdf-viewer ${isPanning ? 'panning' : ''}`}\n          onMouseDown={handleViewerMouseDown}\n          onMouseMove={handleViewerMouseMove}\n          onMouseUp={handleViewerMouseUp}\n          onMouseLeave={handleViewerMouseUp}\n        >\n          <div className=\"zoom-controls\">\n            <button onClick={() => setZoom(Math.max(0.5, zoom - 0.25))}>üîç-</button>\n            <span>{Math.round(zoom * 100)}%</span>\n            <button onClick={() => setZoom(Math.min(4, zoom + 0.25))}>üîç+</button>\n            <button onClick={() => setZoom(1.5)}>Reset</button>\n          </div>\n          <div className=\"pdf-container-wrapper\">\n            <div className=\"pdf-container\">\n              <canvas ref={canvasRef} style={{ position: 'absolute' }} />\n              <canvas \n                ref={overlayCanvasRef}\n                onMouseDown={handleMouseDown}\n                onMouseMove={handleMouseMove}\n                onMouseUp={handleMouseUp}\n                onMouseLeave={() => {\n                  if (isDrawingRect) handleMouseUp();\n                }}\n                style={{ position: 'absolute', cursor: isDrawingRect ? 'crosshair' : 'crosshair' }}\n              />\n            </div>\n          </div>\n        </div>\n\n        <div className=\"fields-panel\">\n          <div className=\"panel-section\">\n            <h3>{editingField ? 'Edit Field' : 'Add New Field'}</h3>\n            \n            {editingField ? (\n              <div className=\"edit-info\">\n                <strong>Editing: {editingField}</strong>\n                <button className=\"cancel-edit-btn\" onClick={handleCancelEdit}>Cancel</button>\n              </div>\n            ) : (\n              <div className=\"control-group\">\n                <label>Field Name:</label>\n                <input\n                  type=\"text\"\n                  value={newFieldName}\n                  onChange={(e) => setNewFieldName(e.target.value)}\n                  placeholder=\"e.g., customer_name\"\n                />\n              </div>\n            )}\n\n            <div className=\"control-row\">\n              <div className=\"control-group\">\n                <label>Font Size:</label>\n                <input\n                  type=\"number\"\n                  value={fontSize}\n                  onChange={(e) => setFontSize(Number(e.target.value))}\n                  min=\"6\"\n                  max=\"72\"\n                />\n              </div>\n              <div className=\"control-group\">\n                <label>Align:</label>\n                <select\n                  value={alignment}\n                  onChange={(e) => setAlignment(e.target.value as 'left' | 'center' | 'right')}\n                >\n                  <option value=\"left\">Left</option>\n                  <option value=\"center\">Center</option>\n                  <option value=\"right\">Right</option>\n                </select>\n              </div>\n            </div>\n\n            <div className=\"control-row\">\n              <div className=\"control-group\">\n                <label>Font Family:</label>\n                <select\n                  value={fontFamily}\n                  onChange={(e) => setFontFamily(e.target.value)}\n                >\n                  <option value=\"Helvetica\">Helvetica</option>\n                  <option value=\"Times-Roman\">Times Roman</option>\n                  <option value=\"Courier\">Courier</option>\n                </select>\n              </div>\n            </div>\n\n            <div className=\"control-group\">\n              <label>Text Color:</label>\n              <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>\n                <input\n                  type=\"color\"\n                  value={textColor}\n                  onChange={(e) => setTextColor(e.target.value)}\n                  style={{ width: '50px', height: '35px' }}\n                />\n                <input\n                  type=\"text\"\n                  value={textColor}\n                  onChange={(e) => setTextColor(e.target.value)}\n                  placeholder=\"#000000\"\n                  style={{ flex: 1 }}\n                />\n              </div>\n            </div>\n\n            <div className=\"control-row checkbox-row\">\n              <label className=\"checkbox-label\">\n                <input\n                  type=\"checkbox\"\n                  checked={bold}\n                  onChange={(e) => setBold(e.target.checked)}\n                />\n                <span>Bold</span>\n              </label>\n              <label className=\"checkbox-label\">\n                <input\n                  type=\"checkbox\"\n                  checked={italic}\n                  onChange={(e) => setItalic(e.target.checked)}\n                />\n                <span>Italic</span>\n              </label>\n            </div>\n\n            <div className=\"section-divider\">\n              <h4>Position & Size</h4>\n            </div>\n\n            <div className=\"control-row\">\n              <div className=\"control-group\">\n                <label>X Position:</label>\n                <input\n                  type=\"number\"\n                  value={manualX}\n                  onChange={(e) => setManualX(Number(e.target.value))}\n                  min=\"0\"\n                />\n              </div>\n              <div className=\"control-group\">\n                <label>Y Position:</label>\n                <input\n                  type=\"number\"\n                  value={manualY}\n                  onChange={(e) => setManualY(Number(e.target.value))}\n                  min=\"0\"\n                />\n              </div>\n            </div>\n\n            <div className=\"control-row\">\n              <div className=\"control-group\">\n                <label>Width:</label>\n                <input\n                  type=\"number\"\n                  value={manualWidth}\n                  onChange={(e) => setManualWidth(Number(e.target.value))}\n                  min=\"10\"\n                />\n              </div>\n              <div className=\"control-group\">\n                <label>Height:</label>\n                <input\n                  type=\"number\"\n                  value={manualHeight}\n                  onChange={(e) => setManualHeight(Number(e.target.value))}\n                  min=\"5\"\n                />\n              </div>\n            </div>\n\n            <div className=\"control-row\">\n              <div className=\"control-group\">\n                <label className=\"checkbox-label\">\n                  <input\n                    type=\"checkbox\"\n                    checked={snapToGrid}\n                    onChange={(e) => setSnapToGrid(e.target.checked)}\n                  />\n                  <span>Snap to Grid</span>\n                </label>\n              </div>\n              <div className=\"control-group\">\n                <label>Grid Size:</label>\n                <input\n                  type=\"number\"\n                  value={gridSize}\n                  onChange={(e) => setGridSize(Number(e.target.value))}\n                  min=\"5\"\n                  max=\"50\"\n                  disabled={!snapToGrid}\n                />\n              </div>\n            </div>\n\n            <button className=\"apply-manual-btn\" onClick={handleManualApply}>\n              ‚úì Apply Position & Size\n            </button>\n\n            <div className=\"instruction\">\n              {editingField \n                ? 'üéØ Drag on PDF or use manual inputs to redefine field area'\n                : 'üéØ Drag on PDF or use manual inputs to define field area'}\n            </div>\n          </div>\n\n          <div className=\"panel-section\">\n            <div className=\"fields-header\">\n              <h3>Mapped Fields ({Object.keys(mapping).length})</h3>\n              <button className=\"save-btn\" onClick={handleSaveMapping}>\n                üíæ Save Mapping\n              </button>\n            </div>\n            {Object.keys(mapping).length === 0 ? (\n              <div className=\"no-fields\">\n                <p>No fields mapped yet</p>\n                <p className=\"hint\">Drag on PDF to add fields</p>\n              </div>\n            ) : (\n              <div className=\"fields-items\">\n                {Object.entries(mapping).map(([fieldName, field]) => (\n                  <div key={fieldName} className={`field-item ${editingField === fieldName ? 'editing' : ''}`}>\n                    <div className=\"field-info\">\n                      <div className=\"field-name\">{fieldName}</div>\n                      <div className=\"field-details\">\n                        x:{field.x}, y:{field.y}, size:{field.size}\n                        <br />\n                        area: {field.maxWidth || 200}√ó{field.maxHeight || 20}\n                        <br />\n                        {field.fontFamily || 'Helvetica'}, {field.color || '#000'}\n                      </div>\n                    </div>\n                    <div className=\"field-actions\">\n                      <button\n                        className=\"edit-btn\"\n                        onClick={() => handleEditField(fieldName)}\n                        title=\"Edit field\"\n                      >\n                        ‚úèÔ∏è\n                      </button>\n                      <button\n                        className=\"delete-btn\"\n                        onClick={() => handleDeleteField(fieldName)}\n                        title=\"Delete field\"\n                      >\n                        üóëÔ∏è\n                      </button>\n                    </div>\n                  </div>\n                ))}\n              </div>\n            )}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default PDFMapper;\n","size_bytes":21251},"client/src/components/TestGenerator.tsx":{"content":"import { useState, useEffect } from 'react';\nimport './TestGenerator.css';\n\ninterface FieldMapping {\n  x: number;\n  y: number;\n  size: number;\n  align?: 'left' | 'center' | 'right';\n}\n\ninterface TemplateMapping {\n  [fieldName: string]: FieldMapping;\n}\n\ninterface Props {\n  templateName: string;\n}\n\nfunction TestGenerator({ templateName }: Props) {\n  const [mapping, setMapping] = useState<TemplateMapping>({});\n  const [testData, setTestData] = useState<{ [key: string]: string }>({});\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [pdfPreviewUrl, setPdfPreviewUrl] = useState<string | null>(null);\n\n  useEffect(() => {\n    loadMapping();\n    return () => {\n      if (pdfPreviewUrl) {\n        URL.revokeObjectURL(pdfPreviewUrl);\n      }\n    };\n  }, [templateName]);\n\n  const loadMapping = async () => {\n    try {\n      const response = await fetch(`/api/mappings/${templateName}`);\n      if (response.ok) {\n        const data = await response.json();\n        setMapping(data);\n        \n        const initialData: { [key: string]: string } = {};\n        Object.keys(data).forEach((field) => {\n          initialData[field] = '';\n        });\n        setTestData(initialData);\n      }\n    } catch (error) {\n      console.error('Failed to load mapping:', error);\n    }\n  };\n\n  const handleFieldChange = (fieldName: string, value: string) => {\n    setTestData({\n      ...testData,\n      [fieldName]: value,\n    });\n  };\n\n  const handleGenerate = async () => {\n    setIsGenerating(true);\n    try {\n      const response = await fetch('/api/generate', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          template: templateName,\n          data: testData,\n        }),\n      });\n\n      if (response.ok) {\n        const blob = await response.blob();\n        \n        if (pdfPreviewUrl) {\n          URL.revokeObjectURL(pdfPreviewUrl);\n        }\n        \n        const url = URL.createObjectURL(blob);\n        setPdfPreviewUrl(url);\n      } else {\n        const error = await response.json();\n        alert(`Failed to generate PDF: ${error.error}`);\n      }\n    } catch (error) {\n      console.error('Generation error:', error);\n      alert('Failed to generate PDF');\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (pdfPreviewUrl) {\n      const link = document.createElement('a');\n      link.href = pdfPreviewUrl;\n      link.download = templateName.replace('.pdf', '_filled.pdf');\n      link.click();\n    }\n  };\n\n  const fieldCount = Object.keys(mapping).length;\n\n  if (fieldCount === 0) {\n    return (\n      <div className=\"test-generator\">\n        <div className=\"no-mapping\">\n          <h3>No mapping defined</h3>\n          <p>Please create a field mapping first using the Field Mapper tab</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"test-generator\">\n      <div className=\"test-layout\">\n        <div className=\"test-sidebar\">\n          <div className=\"test-header\">\n            <h3>Test PDF Generation</h3>\n            <p>Fill in test data and generate a preview</p>\n          </div>\n\n          <div className=\"test-form\">\n            {Object.keys(mapping).map((fieldName) => (\n              <div key={fieldName} className=\"form-group\">\n                <label>{fieldName}</label>\n                <input\n                  type=\"text\"\n                  value={testData[fieldName] || ''}\n                  onChange={(e) => handleFieldChange(fieldName, e.target.value)}\n                  placeholder={`Enter ${fieldName}`}\n                />\n              </div>\n            ))}\n          </div>\n\n          <div className=\"test-actions\">\n            <button\n              className=\"generate-btn\"\n              onClick={handleGenerate}\n              disabled={isGenerating}\n            >\n              {isGenerating ? '‚è≥ Generating...' : 'üé® Generate Preview'}\n            </button>\n            {pdfPreviewUrl && (\n              <button\n                className=\"download-btn\"\n                onClick={handleDownload}\n              >\n                üì• Download PDF\n              </button>\n            )}\n          </div>\n        </div>\n\n        <div className=\"test-preview\">\n          {pdfPreviewUrl ? (\n            <div className=\"pdf-preview-container\">\n              <div className=\"preview-header\">\n                <h4>üìÑ PDF Preview</h4>\n              </div>\n              <iframe\n                src={pdfPreviewUrl}\n                className=\"pdf-preview-frame\"\n                title=\"PDF Preview\"\n              />\n            </div>\n          ) : (\n            <div className=\"no-preview\">\n              <div className=\"no-preview-content\">\n                <span className=\"preview-icon\">üìÑ</span>\n                <h3>No Preview Yet</h3>\n                <p>Fill in the fields and click \"Generate Preview\" to see your PDF</p>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default TestGenerator;\n","size_bytes":5034},"client/src/components/CombinationsManager.tsx":{"content":"import { useState, useEffect } from 'react';\nimport VisualPlacementEditor from './VisualPlacementEditor';\nimport './CombinationsManager.css';\n\ninterface Combination {\n  name: string;\n  templateName: string;\n  drawingPlacements: DrawingPlacement[];\n}\n\ninterface DrawingPlacement {\n  drawingName: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  rotation?: number;\n}\n\ninterface CombinationInfo {\n  name: string;\n}\n\ninterface TemplateInfo {\n  name: string;\n  hasMapping: boolean;\n}\n\ninterface DrawingInfo {\n  name: string;\n  type: string;\n  hasMapping: boolean;\n}\n\ninterface FieldMapping {\n  x: number;\n  y: number;\n  size: number;\n}\n\ninterface TemplateMapping {\n  [fieldName: string]: FieldMapping;\n}\n\nfunction CombinationsManager() {\n  const [combinations, setCombinations] = useState<CombinationInfo[]>([]);\n  const [selectedCombination, setSelectedCombination] = useState<string | null>(null);\n  const [currentCombination, setCurrentCombination] = useState<Combination | null>(null);\n  const [isCreating, setIsCreating] = useState(false);\n  const [newCombinationName, setNewCombinationName] = useState('');\n  const [templates, setTemplates] = useState<TemplateInfo[]>([]);\n  const [drawings, setDrawings] = useState<DrawingInfo[]>([]);\n  const [viewMode, setViewMode] = useState<'edit' | 'test'>('edit');\n  const [templateData, setTemplateData] = useState<{ [key: string]: string }>({});\n  const [drawingsData, setDrawingsData] = useState<{ [drawingName: string]: { [key: string]: string } }>({});\n  const [templateMapping, setTemplateMapping] = useState<TemplateMapping>({});\n  const [drawingsMappings, setDrawingsMappings] = useState<{ [drawingName: string]: TemplateMapping }>({});\n  const [isGenerating, setIsGenerating] = useState(false);\n  const [pdfPreviewUrl, setPdfPreviewUrl] = useState<string | null>(null);\n\n  const loadCombinations = async () => {\n    try {\n      const response = await fetch('/api/combinations');\n      const data = await response.json();\n      setCombinations(data);\n    } catch (error) {\n      console.error('Failed to load combinations:', error);\n    }\n  };\n\n  const loadTemplates = async () => {\n    try {\n      const response = await fetch('/api/templates');\n      const data = await response.json();\n      setTemplates(data);\n    } catch (error) {\n      console.error('Failed to load templates:', error);\n    }\n  };\n\n  const loadDrawings = async () => {\n    try {\n      const response = await fetch('/api/drawings');\n      const data = await response.json();\n      setDrawings(data);\n    } catch (error) {\n      console.error('Failed to load drawings:', error);\n    }\n  };\n\n  useEffect(() => {\n    loadCombinations();\n    loadTemplates();\n    loadDrawings();\n  }, []);\n\n  const handleSelectCombination = async (name: string) => {\n    setSelectedCombination(name);\n    setIsCreating(false);\n    setViewMode('edit');\n    setPdfPreviewUrl(null);\n    \n    try {\n      const response = await fetch(`/api/combinations/${name}`);\n      const data = await response.json();\n      setCurrentCombination(data);\n      await loadMappingsForCombination(data);\n    } catch (error) {\n      console.error('Failed to load combination:', error);\n    }\n  };\n\n  const loadMappingsForCombination = async (combination: Combination) => {\n    try {\n      const templateResp = await fetch(`/api/mappings/${combination.templateName}`);\n      if (templateResp.ok) {\n        const tMapping = await templateResp.json();\n        setTemplateMapping(tMapping);\n        \n        const initialTemplateData: { [key: string]: string } = {};\n        Object.keys(tMapping).forEach((field) => {\n          initialTemplateData[field] = '';\n        });\n        setTemplateData(initialTemplateData);\n      }\n\n      const drawingMappingsTemp: { [drawingName: string]: TemplateMapping } = {};\n      const initialDrawingsData: { [drawingName: string]: { [key: string]: string } } = {};\n\n      for (const placement of combination.drawingPlacements) {\n        const drawingResp = await fetch(`/api/drawing-mappings/${placement.drawingName}`);\n        if (drawingResp.ok) {\n          const dMapping = await drawingResp.json();\n          drawingMappingsTemp[placement.drawingName] = dMapping;\n          \n          const initialDrawingData: { [key: string]: string } = {};\n          Object.keys(dMapping).forEach((field) => {\n            initialDrawingData[field] = '';\n          });\n          initialDrawingsData[placement.drawingName] = initialDrawingData;\n        } else {\n          initialDrawingsData[placement.drawingName] = {};\n        }\n      }\n\n      setDrawingsMappings(drawingMappingsTemp);\n      setDrawingsData(initialDrawingsData);\n    } catch (error) {\n      console.error('Failed to load mappings:', error);\n    }\n  };\n\n  const handleGenerate = async () => {\n    if (!selectedCombination) return;\n\n    setIsGenerating(true);\n    try {\n      const response = await fetch('/api/generate-combination', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          combination: selectedCombination,\n          templateData: templateData,\n          drawingsData: drawingsData,\n        }),\n      });\n\n      if (response.ok) {\n        const blob = await response.blob();\n        \n        if (pdfPreviewUrl) {\n          URL.revokeObjectURL(pdfPreviewUrl);\n        }\n        \n        const url = URL.createObjectURL(blob);\n        setPdfPreviewUrl(url);\n      } else {\n        const error = await response.json();\n        alert(`Failed to generate PDF: ${error.error}`);\n      }\n    } catch (error) {\n      console.error('Generation error:', error);\n      alert('Failed to generate PDF');\n    } finally {\n      setIsGenerating(false);\n    }\n  };\n\n  const handleDownload = () => {\n    if (pdfPreviewUrl) {\n      const link = document.createElement('a');\n      link.href = pdfPreviewUrl;\n      link.download = `${selectedCombination}_generated.pdf`;\n      link.click();\n    }\n  };\n\n  const handleCreateNew = () => {\n    setIsCreating(true);\n    setSelectedCombination(null);\n    setCurrentCombination({\n      name: '',\n      templateName: templates.length > 0 ? templates[0].name : '',\n      drawingPlacements: []\n    });\n    setNewCombinationName('');\n  };\n\n  const handleSave = async () => {\n    if (!currentCombination) return;\n    \n    const name = isCreating ? newCombinationName : currentCombination.name;\n    \n    if (!name) {\n      alert('Please enter a combination name');\n      return;\n    }\n\n    if (!currentCombination.templateName) {\n      alert('Please select a template');\n      return;\n    }\n\n    const combinationToSave = {\n      ...currentCombination,\n      name\n    };\n\n    try {\n      await fetch(`/api/combinations/${name}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(combinationToSave),\n      });\n\n      alert('Combination saved successfully!');\n      await loadCombinations();\n      setIsCreating(false);\n      setSelectedCombination(name);\n      setCurrentCombination(combinationToSave);\n      await loadMappingsForCombination(combinationToSave);\n    } catch (error) {\n      console.error('Save failed:', error);\n      alert('Failed to save combination');\n    }\n  };\n\n  const handleDelete = async () => {\n    if (!selectedCombination) return;\n    \n    if (!confirm(`Delete combination \"${selectedCombination}\"? This cannot be undone.`)) {\n      return;\n    }\n\n    try {\n      await fetch(`/api/combinations/${selectedCombination}`, {\n        method: 'DELETE',\n      });\n\n      alert('Combination deleted successfully!');\n      setSelectedCombination(null);\n      setCurrentCombination(null);\n      await loadCombinations();\n    } catch (error) {\n      console.error('Delete failed:', error);\n      alert('Failed to delete combination');\n    }\n  };\n\n  return (\n    <div className=\"combinations-manager\">\n      <div className=\"combinations-sidebar\">\n        <h2>Combinations</h2>\n        <p className=\"combinations-subtitle\">Connect templates with drawings</p>\n        \n        <button\n          className=\"create-combination-btn\"\n          onClick={handleCreateNew}\n        >\n          + New Combination\n        </button>\n\n        <div className=\"combinations-list\">\n          {combinations.length === 0 ? (\n            <div className=\"no-combinations\">\n              <p>No combinations yet</p>\n              <p className=\"hint\">Create one to get started</p>\n            </div>\n          ) : (\n            combinations.map((combo) => (\n              <div\n                key={combo.name}\n                className={`combination-item ${selectedCombination === combo.name ? 'selected' : ''}`}\n                onClick={() => handleSelectCombination(combo.name)}\n              >\n                <div className=\"combination-icon\">üîó</div>\n                <div className=\"combination-name\">{combo.name}</div>\n              </div>\n            ))\n          )}\n        </div>\n      </div>\n\n      <div className=\"combinations-editor\">\n        {!currentCombination && !isCreating ? (\n          <div className=\"no-selection\">\n            <h2>üëà Select a combination to get started</h2>\n            <p>or create a new one</p>\n          </div>\n        ) : (\n          <div className=\"editor-content\">\n            <div className=\"editor-header\">\n              <h2>{isCreating ? 'New Combination' : currentCombination?.name}</h2>\n              <div className=\"editor-actions\">\n                {!isCreating && (\n                  <div className=\"view-mode-tabs\">\n                    <button\n                      className={`mode-tab ${viewMode === 'edit' ? 'active' : ''}`}\n                      onClick={() => setViewMode('edit')}\n                    >\n                      ‚öôÔ∏è Edit\n                    </button>\n                    <button\n                      className={`mode-tab ${viewMode === 'test' ? 'active' : ''}`}\n                      onClick={() => {\n                        setViewMode('test');\n                        if (currentCombination) {\n                          loadMappingsForCombination(currentCombination);\n                        }\n                      }}\n                    >\n                      üß™ Test & Preview\n                    </button>\n                  </div>\n                )}\n                <button className=\"save-btn\" onClick={handleSave}>\n                  üíæ Save\n                </button>\n                {!isCreating && (\n                  <button className=\"delete-btn\" onClick={handleDelete}>\n                    üóëÔ∏è Delete\n                  </button>\n                )}\n              </div>\n            </div>\n\n            {viewMode === 'edit' ? (\n              <>\n                {isCreating && (\n                  <div className=\"form-group\">\n                    <label>Combination Name:</label>\n                    <input\n                      type=\"text\"\n                      value={newCombinationName}\n                      onChange={(e) => setNewCombinationName(e.target.value)}\n                      placeholder=\"e.g., Customer Drawing Package\"\n                      className=\"combination-name-input\"\n                    />\n                  </div>\n                )}\n\n                <div className=\"form-group\">\n              <label>Template:</label>\n              <select\n                value={currentCombination?.templateName || ''}\n                onChange={(e) => setCurrentCombination({\n                  ...currentCombination!,\n                  templateName: e.target.value\n                })}\n                className=\"template-select\"\n              >\n                {templates.map((template) => (\n                  <option key={template.name} value={template.name}>\n                    {template.name} {template.hasMapping ? '‚úì' : ''}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"form-group visual-placement-container\">\n              <label>Visual Drawing Placement:</label>\n              {currentCombination?.templateName ? (\n                <VisualPlacementEditor\n                  templateName={currentCombination.templateName}\n                  placements={currentCombination.drawingPlacements}\n                  onPlacementsChange={async (newPlacements) => {\n                    setCurrentCombination({\n                      ...currentCombination,\n                      drawingPlacements: newPlacements\n                    });\n\n                    const newDrawingsMappings: { [drawingName: string]: TemplateMapping } = {};\n                    const newDrawingsData: { [drawingName: string]: { [key: string]: string } } = {};\n\n                    const mappingFetches = newPlacements.map(async (placement) => {\n                      if (drawingsMappings[placement.drawingName]) {\n                        newDrawingsMappings[placement.drawingName] = drawingsMappings[placement.drawingName];\n                        newDrawingsData[placement.drawingName] = drawingsData[placement.drawingName] || {};\n                      } else {\n                        try {\n                          const resp = await fetch(`/api/drawing-mappings/${placement.drawingName}`);\n                          if (resp.ok) {\n                            const mapping = await resp.json();\n                            newDrawingsMappings[placement.drawingName] = mapping;\n                            \n                            const initialData: { [key: string]: string } = {};\n                            Object.keys(mapping).forEach((field) => {\n                              initialData[field] = drawingsData[placement.drawingName]?.[field] || '';\n                            });\n                            newDrawingsData[placement.drawingName] = initialData;\n                          } else {\n                            newDrawingsData[placement.drawingName] = {};\n                          }\n                        } catch (error) {\n                          console.error(`Failed to load mapping for ${placement.drawingName}:`, error);\n                          newDrawingsData[placement.drawingName] = {};\n                        }\n                      }\n                    });\n\n                    await Promise.all(mappingFetches);\n\n                    setDrawingsMappings(newDrawingsMappings);\n                    setDrawingsData(newDrawingsData);\n                  }}\n                  drawings={drawings.map(d => d.name)}\n                />\n              ) : (\n                <div className=\"no-placements\">\n                  <p>Please select a template first</p>\n                </div>\n              )}\n            </div>\n              </>\n            ) : (\n              <div className=\"test-layout\">\n                <div className=\"test-sidebar\">\n                  <div className=\"test-header\">\n                    <h3>Test Combination</h3>\n                    <p>Fill in data for template and drawings</p>\n                  </div>\n\n                  <div className=\"test-form\">\n                    {Object.keys(templateMapping).length > 0 && (\n                      <div className=\"test-section\">\n                        <h4>Template Fields ({currentCombination?.templateName})</h4>\n                        {Object.keys(templateMapping).map((fieldName) => (\n                          <div key={fieldName} className=\"form-group\">\n                            <label>{fieldName}</label>\n                            <input\n                              type=\"text\"\n                              value={templateData[fieldName] || ''}\n                              onChange={(e) => setTemplateData({ ...templateData, [fieldName]: e.target.value })}\n                              placeholder={`Enter ${fieldName}`}\n                            />\n                          </div>\n                        ))}\n                      </div>\n                    )}\n\n                    {currentCombination?.drawingPlacements.map((placement) => {\n                      const drawingMapping = drawingsMappings[placement.drawingName];\n                      if (!drawingMapping || Object.keys(drawingMapping).length === 0) {\n                        return null;\n                      }\n\n                      return (\n                        <div key={placement.drawingName} className=\"test-section\">\n                          <h4>Drawing: {placement.drawingName}</h4>\n                          {Object.keys(drawingMapping).map((fieldName) => (\n                            <div key={fieldName} className=\"form-group\">\n                              <label>{fieldName}</label>\n                              <input\n                                type=\"text\"\n                                value={drawingsData[placement.drawingName]?.[fieldName] || ''}\n                                onChange={(e) => {\n                                  const newDrawingsData = { ...drawingsData };\n                                  if (!newDrawingsData[placement.drawingName]) {\n                                    newDrawingsData[placement.drawingName] = {};\n                                  }\n                                  newDrawingsData[placement.drawingName][fieldName] = e.target.value;\n                                  setDrawingsData(newDrawingsData);\n                                }}\n                                placeholder={`Enter ${fieldName}`}\n                              />\n                            </div>\n                          ))}\n                        </div>\n                      );\n                    })}\n                  </div>\n\n                  <div className=\"test-actions\">\n                    <button\n                      className=\"generate-btn\"\n                      onClick={handleGenerate}\n                      disabled={isGenerating}\n                    >\n                      {isGenerating ? '‚è≥ Generating...' : 'üé® Generate Preview'}\n                    </button>\n                    {pdfPreviewUrl && (\n                      <button\n                        className=\"download-btn\"\n                        onClick={handleDownload}\n                      >\n                        üì• Download PDF\n                      </button>\n                    )}\n                  </div>\n                </div>\n\n                <div className=\"test-preview\">\n                  {pdfPreviewUrl ? (\n                    <div className=\"pdf-preview-container\">\n                      <div className=\"preview-header\">\n                        <h4>üìÑ PDF Preview</h4>\n                        <p>Template with drawings at specified positions</p>\n                      </div>\n                      <iframe\n                        src={pdfPreviewUrl}\n                        className=\"pdf-preview-frame\"\n                        title=\"PDF Preview\"\n                      />\n                    </div>\n                  ) : (\n                    <div className=\"no-preview\">\n                      <div className=\"no-preview-content\">\n                        <span className=\"preview-icon\">üìÑ</span>\n                        <h3>No Preview Yet</h3>\n                        <p>Fill in the fields and click \"Generate Preview\" to see your combined PDF with template and drawings</p>\n                      </div>\n                    </div>\n                  )}\n                </div>\n              </div>\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default CombinationsManager;\n","size_bytes":19465},"QUICK_START.md":{"content":"# Quick Start Guide\n\n## üéØ Your PDF Generator is Ready!\n\nThe application is running at: **http://localhost:5000**\n\n## üìã Step-by-Step Usage\n\n### Step 1: Access the Admin Interface\n\nOpen your browser and navigate to the application. You'll see:\n- A sidebar with templates\n- A main area for mapping and testing\n\n### Step 2: Select a Template\n\nClick on **\"Sample_Quote.pdf\"** from the sidebar (a sample template is already included).\n\n### Step 3: Map Fields\n\n1. Click the **\"Field Mapper\"** tab\n2. Enter a field name: `customer_name`\n3. Set font size: `12`\n4. Set alignment: `left`\n5. **Click on the PDF** where you want the customer name to appear\n6. Repeat for other fields:\n   - `flute_dia` - for product diameter\n   - `price` - for pricing\n   - `coating` - for coating type\n   - `date` - for date\n7. Click **\"üíæ Save Mapping\"**\n\n### Step 4: Test Generation\n\n1. Click the **\"Test Generator\"** tab\n2. Fill in sample values:\n   - customer_name: \"Acme Corporation\"\n   - flute_dia: \"12.5 mm\"\n   - price: \"‚Çπ1,250\"\n   - coating: \"TiAlN\"\n   - date: \"2025-10-29\"\n3. Click **\"üì• Generate & Download PDF\"**\n4. Your filled PDF will download!\n\n### Step 5: Use in ERPNext\n\nCopy the API example from the Test Generator tab and paste it into your ERPNext custom script.\n\n## üîå API Quick Reference\n\n### Generate PDF\n\n```bash\ncurl -X POST http://localhost:5000/api/generate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"template\": \"Sample_Quote.pdf\",\n    \"data\": {\n      \"customer_name\": \"Acme Corp\",\n      \"price\": \"‚Çπ1,250\"\n    }\n  }' \\\n  --output filled.pdf\n```\n\n## üí° Tips\n\n- **Click Accuracy**: Click precisely where you want text to start\n- **Font Size**: Larger fonts (14-16) for headers, smaller (10-12) for details\n- **Alignment**: \n  - Use `left` for most fields\n  - Use `right` for prices/numbers\n  - Use `center` for titles\n- **Coordinates**: Y starts from top (0 is at the top edge)\n\n## üÜò Need Help?\n\n- Templates not showing? Upload a PDF using the \"+ Upload PDF\" button\n- Mapping not saving? Make sure you clicked \"Save Mapping\"\n- PDF generation failing? Check that mapping exists for the template\n- Text overlapping? Adjust X and Y coordinates in the mapper\n\n## üì§ Upload Your Own Template\n\n1. Click **\"+ Upload PDF\"**\n2. Select your PDF file\n3. Click the template in the sidebar\n4. Map all your fields\n5. Save and test!\n\nEnjoy your PDF Generator! üéâ\n","size_bytes":2380},"client/src/components/DrawingManager.tsx":{"content":"import { useState, useEffect, useRef } from 'react';\nimport DrawingMapper from './DrawingMapper';\nimport './DrawingManager.css';\n\ninterface Drawing {\n  name: string;\n  type: 'pdf' | 'image' | 'svg';\n  hasMapping: boolean;\n}\n\ninterface Props {\n  onSelectDrawing?: (name: string) => void;\n}\n\nfunction DrawingManager({ onSelectDrawing }: Props) {\n  const [drawings, setDrawings] = useState<Drawing[]>([]);\n  const [selectedDrawing, setSelectedDrawing] = useState<string | null>(null);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  const loadDrawings = async () => {\n    try {\n      const response = await fetch('/api/drawings');\n      const data = await response.json();\n      setDrawings(data);\n    } catch (error) {\n      console.error('Failed to load drawings:', error);\n    }\n  };\n\n  useEffect(() => {\n    loadDrawings();\n  }, []);\n\n  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (!file) return;\n\n    const allowedTypes = ['application/pdf', 'image/png', 'image/jpeg', 'image/gif', 'image/svg+xml'];\n    if (!allowedTypes.includes(file.type)) {\n      alert('Please select a PDF, PNG, JPG, GIF, or SVG file');\n      return;\n    }\n\n    const formData = new FormData();\n    formData.append('drawing', file);\n\n    try {\n      await fetch('/api/drawings/upload', {\n        method: 'POST',\n        body: formData,\n      });\n      await loadDrawings();\n      alert('Drawing uploaded successfully!');\n      if (fileInputRef.current) {\n        fileInputRef.current.value = '';\n      }\n    } catch (error) {\n      console.error('Upload failed:', error);\n      alert('Failed to upload drawing');\n    }\n  };\n\n  const handleDelete = async (e: React.MouseEvent, drawingName: string) => {\n    e.stopPropagation();\n    \n    if (!confirm(`Delete drawing \"${drawingName}\"? This cannot be undone.`)) {\n      return;\n    }\n\n    try {\n      await fetch(`/api/drawings/${drawingName}`, {\n        method: 'DELETE',\n      });\n      \n      if (selectedDrawing === drawingName) {\n        setSelectedDrawing(null);\n      }\n      \n      await loadDrawings();\n      alert('Drawing deleted successfully!');\n    } catch (error) {\n      console.error('Delete failed:', error);\n      alert('Failed to delete drawing');\n    }\n  };\n\n  const handleRename = async (e: React.MouseEvent, drawingName: string) => {\n    e.stopPropagation();\n    \n    const extension = drawingName.substring(drawingName.lastIndexOf('.'));\n    const nameWithoutExt = drawingName.substring(0, drawingName.lastIndexOf('.'));\n    \n    const newNameWithoutExt = prompt('Enter new name (without extension):', nameWithoutExt);\n    \n    if (!newNameWithoutExt) {\n      return;\n    }\n\n    const newName = newNameWithoutExt + extension;\n\n    try {\n      const response = await fetch(`/api/drawings/${drawingName}/rename`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ newName }),\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error || 'Failed to rename drawing');\n      }\n      \n      if (selectedDrawing === drawingName) {\n        setSelectedDrawing(newName);\n      }\n      \n      await loadDrawings();\n      alert('Drawing renamed successfully!');\n    } catch (error: any) {\n      console.error('Rename failed:', error);\n      alert(error.message || 'Failed to rename drawing');\n    }\n  };\n\n  const handleSelect = (name: string) => {\n    setSelectedDrawing(name);\n    if (onSelectDrawing) {\n      onSelectDrawing(name);\n    }\n  };\n\n  return (\n    <div className=\"drawing-manager-container\">\n      {!selectedDrawing ? (\n        <div className=\"drawing-manager\">\n          <div className=\"drawing-header\">\n            <h2>Drawings</h2>\n            <p className=\"drawing-subtitle\">Upload and manage technical drawings for templates</p>\n            <button\n              className=\"upload-drawing-btn\"\n              onClick={() => fileInputRef.current?.click()}\n            >\n              + Upload Drawing\n            </button>\n            <input\n              ref={fileInputRef}\n              type=\"file\"\n              accept=\".pdf,.png,.jpg,.jpeg,.gif,.svg\"\n              onChange={handleFileChange}\n              style={{ display: 'none' }}\n            />\n          </div>\n\n          <div className=\"drawing-grid\">\n            {drawings.length === 0 ? (\n              <div className=\"no-drawings\">\n                <p>No drawings yet</p>\n                <p className=\"hint\">Upload PDF, PNG, JPG, GIF, or SVG files</p>\n              </div>\n            ) : (\n              drawings.map((drawing) => (\n                <div\n                  key={drawing.name}\n                  className={`drawing-card ${selectedDrawing === drawing.name ? 'selected' : ''}`}\n                  onClick={() => handleSelect(drawing.name)}\n                >\n                  <div className=\"drawing-preview\">\n                    {drawing.type === 'pdf' && <span className=\"drawing-icon\">üìÑ</span>}\n                    {drawing.type === 'image' && <span className=\"drawing-icon\">üñºÔ∏è</span>}\n                    {drawing.type === 'svg' && <span className=\"drawing-icon\">üé®</span>}\n                  </div>\n                  <div className=\"drawing-info\">\n                    <div className=\"drawing-name\">{drawing.name}</div>\n                    <div className=\"drawing-type\">\n                      {drawing.type.toUpperCase()}\n                    </div>\n                    {drawing.hasMapping && (\n                      <span className=\"drawing-mapped-badge\">Mapped</span>\n                    )}\n                  </div>\n                  <div className=\"drawing-actions\">\n                    <button\n                      className=\"rename-drawing-btn\"\n                      onClick={(e) => handleRename(e, drawing.name)}\n                      title=\"Rename drawing\"\n                    >\n                      ‚úèÔ∏è\n                    </button>\n                    <button\n                      className=\"delete-drawing-btn\"\n                      onClick={(e) => handleDelete(e, drawing.name)}\n                      title=\"Delete drawing\"\n                    >\n                      üóëÔ∏è\n                    </button>\n                  </div>\n                </div>\n              ))\n            )}\n          </div>\n        </div>\n      ) : (\n        <>\n          <div className=\"drawing-mapper-header\">\n            <button\n              className=\"back-to-list-btn\"\n              onClick={() => {\n                setSelectedDrawing(null);\n              }}\n            >\n              ‚Üê Back to Drawings\n            </button>\n            <h2>{selectedDrawing}</h2>\n          </div>\n          <div style={{ flex: 1, overflow: 'hidden' }}>\n            <DrawingMapper\n              drawingName={selectedDrawing}\n              onMappingSaved={() => loadDrawings()}\n            />\n          </div>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport default DrawingManager;\n","size_bytes":7041},"client/src/index.css":{"content":"* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\nbody {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',\n    sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  background: #f5f7fa;\n}\n\nbutton {\n  cursor: pointer;\n  border: none;\n  outline: none;\n  font-family: inherit;\n}\n\ninput, textarea {\n  font-family: inherit;\n}\n","size_bytes":472},"client/src/components/VisualPlacementEditor.css":{"content":".visual-placement-editor {\n  display: flex;\n  flex-direction: column;\n  height: calc(100vh - 200px);\n  min-height: 600px;\n  background: #f5f5f5;\n  border-radius: 8px;\n  overflow: hidden;\n}\n\n.placement-toolbar {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1rem;\n  background: white;\n  border-bottom: 2px solid #e0e0e0;\n}\n\n.toolbar-left {\n  display: flex;\n  gap: 0.75rem;\n}\n\n.toolbar-btn {\n  padding: 0.5rem 1rem;\n  border-radius: 6px;\n  font-weight: 500;\n  transition: all 0.2s;\n  font-size: 0.9rem;\n  background: #667eea;\n  color: white;\n}\n\n.toolbar-btn:hover {\n  background: #5568d3;\n  transform: translateY(-1px);\n}\n\n.toolbar-btn.danger {\n  background: #dc3545;\n}\n\n.toolbar-btn.danger:hover {\n  background: #c82333;\n}\n\n.zoom-controls {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.zoom-controls label {\n  font-weight: 500;\n  color: #666;\n  font-size: 0.9rem;\n}\n\n.zoom-controls button {\n  min-width: 36px;\n  height: 36px;\n  padding: 0 0.75rem;\n  border-radius: 6px;\n  background: #f0f0f0;\n  color: #333;\n  font-weight: bold;\n  font-size: 1.3rem;\n  transition: all 0.2s;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border: 1px solid #d0d0d0;\n  cursor: pointer;\n}\n\n.zoom-controls button:hover {\n  background: #667eea;\n  color: white;\n  border-color: #667eea;\n  transform: translateY(-1px);\n}\n\n.zoom-controls span {\n  min-width: 50px;\n  text-align: center;\n  font-weight: 500;\n  color: #333;\n}\n\n.placement-properties {\n  padding: 1rem;\n  background: white;\n  border-bottom: 2px solid #e0e0e0;\n}\n\n.placement-properties h4 {\n  margin: 0 0 0.75rem 0;\n  color: #667eea;\n  font-size: 1rem;\n}\n\n.properties-grid {\n  display: grid;\n  grid-template-columns: 2fr repeat(4, 1fr);\n  gap: 0.75rem;\n}\n\n.prop-field {\n  display: flex;\n  flex-direction: column;\n  gap: 0.25rem;\n}\n\n.prop-field label {\n  font-size: 0.875rem;\n  font-weight: 500;\n  color: #666;\n}\n\n.prop-field select,\n.prop-field input {\n  padding: 0.5rem;\n  border: 1px solid #e0e0e0;\n  border-radius: 6px;\n  font-size: 0.95rem;\n}\n\n.prop-field select:focus,\n.prop-field input:focus {\n  outline: none;\n  border-color: #667eea;\n}\n\n.canvas-container {\n  flex: 1;\n  position: relative;\n  overflow: auto;\n  background: #2a2a2a;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 1rem;\n  cursor: grab;\n}\n\n.canvas-container.panning {\n  cursor: grabbing;\n}\n\n.canvas-wrapper {\n  position: relative;\n  display: inline-block;\n  flex-shrink: 0;\n}\n\n.pdf-canvas {\n  display: block;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.overlay-canvas {\n  position: absolute;\n  top: 0;\n  left: 0;\n  cursor: crosshair;\n  pointer-events: all;\n}\n\n.overlay-canvas:active:not(.panning) {\n  cursor: move;\n}\n\n.canvas-container.panning .overlay-canvas {\n  pointer-events: none;\n}\n\n.placement-help {\n  padding: 0.75rem 1rem;\n  background: #fffbea;\n  border-top: 2px solid #f5e6a8;\n  text-align: center;\n}\n\n.placement-help p {\n  margin: 0;\n  color: #856404;\n  font-size: 0.9rem;\n}\n\n.placement-help strong {\n  color: #533c04;\n}\n","size_bytes":3050},"client/src/App.css":{"content":".app {\n  height: 100vh;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.header {\n  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n  color: white;\n  padding: 1rem 1.5rem;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n  flex-shrink: 0;\n}\n\n.header-left {\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n}\n\n.header h1 {\n  font-size: 1.5rem;\n  margin: 0;\n}\n\n.header p {\n  opacity: 0.9;\n  font-size: 0.875rem;\n  margin: 0;\n}\n\n.sidebar-toggle {\n  padding: 0.5rem 1rem;\n  background: rgba(255, 255, 255, 0.2);\n  color: white;\n  border-radius: 6px;\n  font-weight: 500;\n  transition: all 0.2s;\n  border: 1px solid rgba(255, 255, 255, 0.3);\n}\n\n.sidebar-toggle:hover {\n  background: rgba(255, 255, 255, 0.3);\n}\n\n.main-view-tabs {\n  display: flex;\n  gap: 0.5rem;\n}\n\n.main-view-tab {\n  padding: 0.5rem 1.5rem;\n  background: rgba(255, 255, 255, 0.15);\n  color: rgba(255, 255, 255, 0.8);\n  border-radius: 6px;\n  font-weight: 500;\n  transition: all 0.2s;\n  border: 1px solid rgba(255, 255, 255, 0.2);\n}\n\n.main-view-tab:hover {\n  background: rgba(255, 255, 255, 0.25);\n  color: white;\n}\n\n.main-view-tab.active {\n  background: white;\n  color: #667eea;\n  border-color: white;\n}\n\n.container {\n  display: flex;\n  flex: 1;\n  overflow: hidden;\n  position: relative;\n}\n\n.sidebar {\n  width: 320px;\n  flex-shrink: 0;\n  background: #f8f9fa;\n  border-right: 1px solid #e0e0e0;\n  overflow-y: auto;\n  transition: transform 0.3s ease, width 0.3s ease;\n}\n\n.sidebar.collapsed {\n  transform: translateX(-100%);\n  width: 0;\n}\n\n.main-content {\n  flex: 1;\n  background: white;\n  overflow: hidden;\n  display: flex;\n  flex-direction: column;\n}\n\n.tabs {\n  display: flex;\n  border-bottom: 1px solid #e0e0e0;\n  background: #fafafa;\n  flex-shrink: 0;\n}\n\n.tab {\n  padding: 0.75rem 1.5rem;\n  background: transparent;\n  color: #666;\n  font-weight: 500;\n  transition: all 0.2s;\n}\n\n.tab:hover {\n  background: rgba(102, 126, 234, 0.1);\n  color: #667eea;\n}\n\n.tab.active {\n  background: white;\n  color: #667eea;\n  border-bottom: 3px solid #667eea;\n}\n\n.empty-state {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  flex: 1;\n  color: #999;\n  text-align: center;\n}\n\n.empty-state h2 {\n  font-size: 1.5rem;\n  margin-bottom: 0.5rem;\n}\n\n.empty-state p {\n  font-size: 1rem;\n}\n","size_bytes":2376},"client/src/components/TemplateList.css":{"content":".template-list {\n  background: white;\n  border-radius: 12px;\n  box-shadow: 0 2px 20px rgba(0, 0, 0, 0.08);\n  overflow: hidden;\n  height: fit-content;\n}\n\n.template-list-header {\n  padding: 1.5rem;\n  border-bottom: 1px solid #e0e0e0;\n  background: #fafafa;\n}\n\n.template-list-header h2 {\n  font-size: 1.25rem;\n  margin-bottom: 1rem;\n  color: #333;\n}\n\n.upload-btn {\n  width: 100%;\n  padding: 0.75rem;\n  background: #667eea;\n  color: white;\n  border-radius: 8px;\n  font-weight: 500;\n  transition: all 0.2s;\n}\n\n.upload-btn:hover {\n  background: #5568d3;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);\n}\n\n.template-items {\n  max-height: 600px;\n  overflow-y: auto;\n}\n\n.no-templates {\n  padding: 3rem 1.5rem;\n  text-align: center;\n  color: #999;\n}\n\n.no-templates .hint {\n  font-size: 0.875rem;\n  margin-top: 0.5rem;\n}\n\n.template-item {\n  display: flex;\n  align-items: center;\n  padding: 1rem 1.5rem;\n  border-bottom: 1px solid #f0f0f0;\n  cursor: pointer;\n  transition: all 0.2s;\n}\n\n.template-item:hover {\n  background: #f8f9fa;\n}\n\n.template-item.selected {\n  background: #e8ebfa;\n  border-left: 4px solid #667eea;\n}\n\n.template-icon {\n  font-size: 1.5rem;\n  margin-right: 1rem;\n}\n\n.template-info {\n  flex: 1;\n}\n\n.template-name {\n  font-weight: 500;\n  color: #333;\n  margin-bottom: 0.25rem;\n  word-break: break-word;\n}\n\n.template-status {\n  margin-top: 0.25rem;\n}\n\n.status-badge {\n  display: inline-block;\n  padding: 0.25rem 0.5rem;\n  border-radius: 4px;\n  font-size: 0.75rem;\n  font-weight: 500;\n}\n\n.status-badge.mapped {\n  background: #d4f4dd;\n  color: #2d6a3e;\n}\n\n.status-badge.unmapped {\n  background: #ffe8cc;\n  color: #8c5e1f;\n}\n\n.delete-template-btn {\n  padding: 0.5rem;\n  background: transparent;\n  font-size: 1.2rem;\n  opacity: 0;\n  transition: all 0.2s;\n  border-radius: 4px;\n}\n\n.template-item:hover .delete-template-btn {\n  opacity: 0.6;\n}\n\n.delete-template-btn:hover {\n  opacity: 1 !important;\n  background: #fee;\n}\n","size_bytes":1952},"client/src/components/TemplateList.tsx":{"content":"import { useRef } from 'react';\nimport './TemplateList.css';\n\ninterface Template {\n  name: string;\n  hasMapping: boolean;\n}\n\ninterface Props {\n  templates: Template[];\n  selectedTemplate: string | null;\n  onSelect: (name: string) => void;\n  onUpload: (file: File) => void;\n  onDelete: (name: string) => void;\n}\n\nfunction TemplateList({ templates, selectedTemplate, onSelect, onUpload, onDelete }: Props) {\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const file = e.target.files?.[0];\n    if (file && file.type === 'application/pdf') {\n      onUpload(file);\n      if (fileInputRef.current) {\n        fileInputRef.current.value = '';\n      }\n    } else {\n      alert('Please select a PDF file');\n    }\n  };\n\n  const handleDelete = (e: React.MouseEvent, templateName: string) => {\n    e.stopPropagation();\n    onDelete(templateName);\n  };\n\n  return (\n    <div className=\"template-list\">\n      <div className=\"template-list-header\">\n        <h2>Templates</h2>\n        <button\n          className=\"upload-btn\"\n          onClick={() => fileInputRef.current?.click()}\n        >\n          + Upload PDF\n        </button>\n        <input\n          ref={fileInputRef}\n          type=\"file\"\n          accept=\".pdf\"\n          onChange={handleFileChange}\n          style={{ display: 'none' }}\n        />\n      </div>\n\n      <div className=\"template-items\">\n        {templates.length === 0 ? (\n          <div className=\"no-templates\">\n            <p>No templates yet</p>\n            <p className=\"hint\">Upload a PDF to get started</p>\n          </div>\n        ) : (\n          templates.map((template) => (\n            <div\n              key={template.name}\n              className={`template-item ${\n                selectedTemplate === template.name ? 'selected' : ''\n              }`}\n              onClick={() => onSelect(template.name)}\n            >\n              <div className=\"template-icon\">üìÑ</div>\n              <div className=\"template-info\">\n                <div className=\"template-name\">{template.name}</div>\n                <div className=\"template-status\">\n                  {template.hasMapping ? (\n                    <span className=\"status-badge mapped\">Mapped</span>\n                  ) : (\n                    <span className=\"status-badge unmapped\">No Mapping</span>\n                  )}\n                </div>\n              </div>\n              <button\n                className=\"delete-template-btn\"\n                onClick={(e) => handleDelete(e, template.name)}\n                title=\"Delete template\"\n              >\n                üóëÔ∏è\n              </button>\n            </div>\n          ))\n        )}\n      </div>\n    </div>\n  );\n}\n\nexport default TemplateList;\n","size_bytes":2773},"src/server.ts":{"content":"import express, { Request, Response } from 'express';\nimport cors from 'cors';\nimport multer from 'multer';\nimport path from 'path';\nimport { PDFService } from './pdfService';\nimport { GenerateRequest, TemplateMapping } from './types';\n\nconst app = express();\nconst port = 5000;\nconst pdfService = new PDFService();\n\nconst storage = multer.memoryStorage();\nconst upload = multer({ storage });\n\napp.use(cors());\napp.use(express.json());\n\napp.use(express.static(path.join(__dirname, '../client/build')));\n\napp.post('/api/generate', async (req: Request, res: Response) => {\n  try {\n    const { template, data }: GenerateRequest = req.body;\n\n    if (!template || !data) {\n      return res.status(400).json({ error: 'Missing template or data' });\n    }\n\n    const pdfBuffer = await pdfService.generatePDF(template, data);\n\n    const filename = template.replace('.pdf', '_filled.pdf');\n\n    res.setHeader('Content-Type', 'application/pdf');\n    res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');\n    res.setHeader('Pragma', 'no-cache');\n    res.setHeader('Expires', '0');\n    \n    res.send(pdfBuffer);\n  } catch (error: any) {\n    console.error('PDF generation error:', error);\n    res.status(500).json({ error: error.message || 'Failed to generate PDF' });\n  }\n});\n\napp.get('/api/templates', async (req: Request, res: Response) => {\n  try {\n    const templates = await pdfService.listTemplates();\n    res.json(templates);\n  } catch (error: any) {\n    console.error('List templates error:', error);\n    res.status(500).json({ error: error.message || 'Failed to list templates' });\n  }\n});\n\napp.get('/api/templates/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    const pdfBuffer = await pdfService.getTemplate(name);\n\n    res.setHeader('Content-Type', 'application/pdf');\n    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');\n    res.send(pdfBuffer);\n  } catch (error: any) {\n    console.error('Get template error:', error);\n    res.status(404).json({ error: error.message || 'Template not found' });\n  }\n});\n\napp.post('/api/templates/upload', upload.single('template'), async (req: Request, res: Response) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ error: 'No file uploaded' });\n    }\n\n    const filename = req.file.originalname;\n    \n    if (!filename.endsWith('.pdf')) {\n      return res.status(400).json({ error: 'Only PDF files are allowed' });\n    }\n\n    await pdfService.saveTemplate(filename, req.file.buffer);\n\n    res.json({ message: 'Template uploaded successfully', filename });\n  } catch (error: any) {\n    console.error('Upload template error:', error);\n    res.status(500).json({ error: error.message || 'Failed to upload template' });\n  }\n});\n\napp.delete('/api/templates/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    await pdfService.deleteTemplate(name);\n    res.json({ message: 'Template deleted successfully' });\n  } catch (error: any) {\n    console.error('Delete template error:', error);\n    res.status(500).json({ error: error.message || 'Failed to delete template' });\n  }\n});\n\napp.get('/api/drawings', async (req: Request, res: Response) => {\n  try {\n    const drawings = await pdfService.listDrawings();\n    res.json(drawings);\n  } catch (error: any) {\n    console.error('List drawings error:', error);\n    res.status(500).json({ error: error.message || 'Failed to list drawings' });\n  }\n});\n\napp.get('/api/drawings/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    const { buffer, contentType } = await pdfService.getDrawing(name);\n\n    res.setHeader('Content-Type', contentType);\n    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');\n    res.send(buffer);\n  } catch (error: any) {\n    console.error('Get drawing error:', error);\n    res.status(404).json({ error: error.message || 'Drawing not found' });\n  }\n});\n\napp.post('/api/drawings/upload', upload.single('drawing'), async (req: Request, res: Response) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ error: 'No file uploaded' });\n    }\n\n    const filename = req.file.originalname;\n    \n    await pdfService.saveDrawing(filename, req.file.buffer);\n\n    res.json({ message: 'Drawing uploaded successfully', filename });\n  } catch (error: any) {\n    console.error('Upload drawing error:', error);\n    res.status(500).json({ error: error.message || 'Failed to upload drawing' });\n  }\n});\n\napp.delete('/api/drawings/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    await pdfService.deleteDrawing(name);\n    res.json({ message: 'Drawing deleted successfully' });\n  } catch (error: any) {\n    console.error('Delete drawing error:', error);\n    res.status(500).json({ error: error.message || 'Failed to delete drawing' });\n  }\n});\n\napp.put('/api/drawings/:name/rename', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    const { newName } = req.body;\n\n    if (!newName) {\n      return res.status(400).json({ error: 'New name is required' });\n    }\n\n    await pdfService.renameDrawing(name, newName);\n    res.json({ message: 'Drawing renamed successfully', newName });\n  } catch (error: any) {\n    console.error('Rename drawing error:', error);\n    res.status(500).json({ error: error.message || 'Failed to rename drawing' });\n  }\n});\n\napp.get('/api/drawing-mappings/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    const mapping = await pdfService.getDrawingMapping(name);\n\n    if (!mapping) {\n      return res.status(404).json({ error: 'Drawing mapping not found' });\n    }\n\n    res.json(mapping);\n  } catch (error: any) {\n    console.error('Get drawing mapping error:', error);\n    res.status(500).json({ error: error.message || 'Failed to get drawing mapping' });\n  }\n});\n\napp.post('/api/drawing-mappings/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    const mapping = req.body;\n\n    await pdfService.saveDrawingMapping(name, mapping);\n\n    res.json({ message: 'Drawing mapping saved successfully' });\n  } catch (error: any) {\n    console.error('Save drawing mapping error:', error);\n    res.status(500).json({ error: error.message || 'Failed to save drawing mapping' });\n  }\n});\n\napp.get('/api/mappings/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    const mapping = await pdfService.getMapping(name);\n\n    if (!mapping) {\n      return res.status(404).json({ error: 'Mapping not found' });\n    }\n\n    res.json(mapping);\n  } catch (error: any) {\n    console.error('Get mapping error:', error);\n    res.status(500).json({ error: error.message || 'Failed to get mapping' });\n  }\n});\n\napp.post('/api/mappings/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    const mapping: TemplateMapping = req.body;\n\n    await pdfService.saveMapping(name, mapping);\n\n    res.json({ message: 'Mapping saved successfully' });\n  } catch (error: any) {\n    console.error('Save mapping error:', error);\n    res.status(500).json({ error: error.message || 'Failed to save mapping' });\n  }\n});\n\napp.get('/api/combinations', async (req: Request, res: Response) => {\n  try {\n    const combinations = await pdfService.listCombinations();\n    res.json(combinations);\n  } catch (error: any) {\n    console.error('List combinations error:', error);\n    res.status(500).json({ error: error.message || 'Failed to list combinations' });\n  }\n});\n\napp.get('/api/combinations/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    const combination = await pdfService.getCombination(name);\n\n    if (!combination) {\n      return res.status(404).json({ error: 'Combination not found' });\n    }\n\n    res.json(combination);\n  } catch (error: any) {\n    console.error('Get combination error:', error);\n    res.status(500).json({ error: error.message || 'Failed to get combination' });\n  }\n});\n\napp.post('/api/combinations/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    const combination = req.body;\n\n    await pdfService.saveCombination(name, combination);\n\n    res.json({ message: 'Combination saved successfully' });\n  } catch (error: any) {\n    console.error('Save combination error:', error);\n    res.status(500).json({ error: error.message || 'Failed to save combination' });\n  }\n});\n\napp.delete('/api/combinations/:name', async (req: Request, res: Response) => {\n  try {\n    const { name } = req.params;\n    await pdfService.deleteCombination(name);\n    res.json({ message: 'Combination deleted successfully' });\n  } catch (error: any) {\n    console.error('Delete combination error:', error);\n    res.status(500).json({ error: error.message || 'Failed to delete combination' });\n  }\n});\n\napp.post('/api/generate-combination', async (req: Request, res: Response) => {\n  try {\n    const { combination, templateData, drawingsData } = req.body;\n\n    console.log('=== Generate Combination Request ===');\n    console.log('Combination:', combination);\n    console.log('Template Data:', JSON.stringify(templateData, null, 2));\n    console.log('Drawings Data:', JSON.stringify(drawingsData, null, 2));\n    console.log('===================================');\n\n    if (!combination) {\n      return res.status(400).json({ error: 'Combination name is required' });\n    }\n\n    if (!templateData) {\n      return res.status(400).json({ error: 'Template data is required' });\n    }\n\n    const pdfBuffer = await pdfService.generateWithCombination(\n      combination,\n      templateData,\n      drawingsData || {}\n    );\n\n    res.setHeader('Content-Type', 'application/pdf');\n    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');\n    res.setHeader('Content-Disposition', `attachment; filename=\"${combination}_generated.pdf\"`);\n    res.send(pdfBuffer);\n  } catch (error: any) {\n    console.error('Generate with combination error:', error);\n    res.status(500).json({ error: error.message || 'Failed to generate PDF' });\n  }\n});\n\napp.get('*', (req: Request, res: Response) => {\n  res.sendFile(path.join(__dirname, '../client/build/index.html'));\n});\n\napp.listen(port, '0.0.0.0', () => {\n  console.log(`PDF Generator Server running on http://0.0.0.0:${port}`);\n  console.log(`API endpoint: http://0.0.0.0:${port}/api/generate`);\n  console.log(`Admin interface: http://0.0.0.0:${port}`);\n});\n","size_bytes":10599},"client/src/App.tsx":{"content":"import { useState, useEffect } from 'react';\nimport TemplateList from './components/TemplateList';\nimport PDFMapper from './components/PDFMapper';\nimport TestGenerator from './components/TestGenerator';\nimport DrawingManager from './components/DrawingManager';\nimport CombinationsManager from './components/CombinationsManager';\nimport './App.css';\n\ninterface Template {\n  name: string;\n  hasMapping: boolean;\n}\n\nfunction App() {\n  const [templates, setTemplates] = useState<Template[]>([]);\n  const [selectedTemplate, setSelectedTemplate] = useState<string | null>(null);\n  const [activeTab, setActiveTab] = useState<'mapper' | 'drawings' | 'test'>('mapper');\n  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);\n  const [mainView, setMainView] = useState<'templates' | 'drawings' | 'combinations'>('templates');\n\n  const loadTemplates = async () => {\n    try {\n      const response = await fetch('/api/templates');\n      const data = await response.json();\n      setTemplates(data);\n    } catch (error) {\n      console.error('Failed to load templates:', error);\n    }\n  };\n\n  useEffect(() => {\n    loadTemplates();\n  }, []);\n\n  const handleUpload = async (file: File) => {\n    const formData = new FormData();\n    formData.append('template', file);\n\n    try {\n      await fetch('/api/templates/upload', {\n        method: 'POST',\n        body: formData,\n      });\n      await loadTemplates();\n      alert('Template uploaded successfully!');\n    } catch (error) {\n      console.error('Upload failed:', error);\n      alert('Failed to upload template');\n    }\n  };\n\n  const handleDelete = async (templateName: string) => {\n    if (!confirm(`Delete template \"${templateName}\"? This cannot be undone.`)) {\n      return;\n    }\n\n    try {\n      await fetch(`/api/templates/${templateName}`, {\n        method: 'DELETE',\n      });\n      \n      if (selectedTemplate === templateName) {\n        setSelectedTemplate(null);\n      }\n      \n      await loadTemplates();\n      alert('Template deleted successfully!');\n    } catch (error) {\n      console.error('Delete failed:', error);\n      alert('Failed to delete template');\n    }\n  };\n\n  return (\n    <div className=\"app\">\n      <header className=\"header\">\n        <div className=\"header-left\">\n          {mainView !== 'combinations' && (\n            <button\n              className=\"sidebar-toggle\"\n              onClick={() => setSidebarCollapsed(!sidebarCollapsed)}\n            >\n              {sidebarCollapsed ? '‚ò∞ Show Sidebar' : '‚úï Hide Sidebar'}\n            </button>\n          )}\n          {mainView === 'combinations' && (\n            <button\n              className=\"sidebar-toggle\"\n              onClick={() => {\n                const sidebar = document.querySelector('.combinations-sidebar');\n                if (sidebar) {\n                  sidebar.classList.toggle('collapsed');\n                }\n              }}\n            >\n              {document.querySelector('.combinations-sidebar.collapsed') ? '‚ò∞ Show Sidebar' : '‚úï Hide Sidebar'}\n            </button>\n          )}\n          <div>\n            <h1>üìÑ PDF Generator Admin</h1>\n          </div>\n        </div>\n        <div className=\"main-view-tabs\">\n          <button\n            className={`main-view-tab ${mainView === 'templates' ? 'active' : ''}`}\n            onClick={() => setMainView('templates')}\n          >\n            Templates\n          </button>\n          <button\n            className={`main-view-tab ${mainView === 'drawings' ? 'active' : ''}`}\n            onClick={() => setMainView('drawings')}\n          >\n            Drawings\n          </button>\n          <button\n            className={`main-view-tab ${mainView === 'combinations' ? 'active' : ''}`}\n            onClick={() => setMainView('combinations')}\n          >\n            Combinations\n          </button>\n        </div>\n      </header>\n\n      <div className=\"container\">\n        {mainView !== 'combinations' && (\n          <div className={`sidebar ${sidebarCollapsed ? 'collapsed' : ''}`}>\n            <TemplateList\n              templates={templates}\n              selectedTemplate={selectedTemplate}\n              onSelect={setSelectedTemplate}\n              onUpload={handleUpload}\n              onDelete={handleDelete}\n            />\n          </div>\n        )}\n\n        <div className=\"main-content\">\n          {mainView === 'templates' ? (\n            selectedTemplate ? (\n              <>\n                <div className=\"tabs\">\n                  <button\n                    className={`tab ${activeTab === 'mapper' ? 'active' : ''}`}\n                    onClick={() => setActiveTab('mapper')}\n                  >\n                    Field Mapper\n                  </button>\n                  <button\n                    className={`tab ${activeTab === 'test' ? 'active' : ''}`}\n                    onClick={() => setActiveTab('test')}\n                  >\n                    Test Generator\n                  </button>\n                </div>\n\n                {activeTab === 'mapper' ? (\n                  <PDFMapper\n                    templateName={selectedTemplate}\n                    onMappingSaved={() => loadTemplates()}\n                  />\n                ) : (\n                  <TestGenerator templateName={selectedTemplate} />\n                )}\n              </>\n            ) : (\n              <div className=\"empty-state\">\n                <h2>üëà Select a template to get started</h2>\n                <p>Upload a PDF template or select an existing one from the sidebar</p>\n              </div>\n            )\n          ) : mainView === 'drawings' ? (\n            <DrawingManager />\n          ) : (\n            <CombinationsManager />\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","size_bytes":5748},"client/src/components/PDFMapper.css":{"content":".pdf-mapper {\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n  overflow: hidden;\n}\n\n.mapper-content {\n  display: flex;\n  flex: 1;\n  overflow: hidden;\n  position: relative;\n}\n\n.pdf-viewer {\n  flex: 1;\n  overflow: auto;\n  padding: 1rem;\n  background: #2a2a2a;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  cursor: default;\n}\n\n.pdf-viewer.panning {\n  cursor: grabbing;\n}\n\n.pdf-viewer.panning canvas {\n  pointer-events: none;\n}\n\n.zoom-controls {\n  display: flex;\n  gap: 0.5rem;\n  align-items: center;\n  justify-content: center;\n  margin-bottom: 1rem;\n  padding: 0.5rem;\n  background: rgba(255, 255, 255, 0.1);\n  border-radius: 8px;\n  flex-shrink: 0;\n}\n\n.zoom-controls button {\n  min-width: 40px;\n  height: 36px;\n  padding: 0 1rem;\n  background: #667eea;\n  color: white;\n  border-radius: 6px;\n  font-weight: 600;\n  font-size: 1.1rem;\n  transition: all 0.2s;\n  cursor: pointer;\n  border: none;\n}\n\n.zoom-controls button:hover {\n  background: #5568d3;\n  transform: translateY(-1px);\n  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);\n}\n\n.zoom-controls span {\n  color: white;\n  font-weight: 500;\n  min-width: 60px;\n  text-align: center;\n}\n\n.pdf-container-wrapper {\n  position: relative;\n  display: inline-block;\n  flex-shrink: 0;\n}\n\n.pdf-container {\n  position: relative;\n  display: block;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);\n}\n\n.pdf-container canvas {\n  display: block;\n}\n\n.fields-panel {\n  width: 420px;\n  border-left: 1px solid #e0e0e0;\n  display: flex;\n  flex-direction: column;\n  background: white;\n  overflow-y: auto;\n}\n\n.panel-section {\n  padding: 1.5rem;\n  border-bottom: 1px solid #e0e0e0;\n}\n\n.panel-section h3 {\n  margin-bottom: 1rem;\n  color: #333;\n  font-size: 1.1rem;\n}\n\n.edit-info {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0.75rem;\n  background: #fef3c7;\n  border: 2px solid #f59e0b;\n  border-radius: 8px;\n  margin-bottom: 1rem;\n}\n\n.edit-info strong {\n  color: #92400e;\n}\n\n.cancel-edit-btn {\n  padding: 0.5rem 1rem;\n  background: #ef4444;\n  color: white;\n  border-radius: 6px;\n  font-size: 0.875rem;\n  font-weight: 500;\n  transition: all 0.2s;\n}\n\n.cancel-edit-btn:hover {\n  background: #dc2626;\n}\n\n.control-group {\n  margin-bottom: 1rem;\n}\n\n.control-group label {\n  display: block;\n  margin-bottom: 0.5rem;\n  font-weight: 500;\n  color: #555;\n  font-size: 0.9rem;\n}\n\n.control-group input,\n.control-group select {\n  width: 100%;\n  padding: 0.5rem;\n  border: 1px solid #ddd;\n  border-radius: 6px;\n  font-size: 0.9rem;\n}\n\n.control-row {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 1rem;\n  margin-bottom: 1rem;\n}\n\n.checkbox-row {\n  display: flex;\n  gap: 2rem;\n  justify-content: flex-start;\n}\n\n.checkbox-label {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n  cursor: pointer;\n  font-size: 0.9rem;\n  color: #555;\n}\n\n.checkbox-label input[type=\"checkbox\"] {\n  width: auto;\n  cursor: pointer;\n}\n\n.section-divider {\n  margin: 1.5rem 0 1rem 0;\n  padding-bottom: 0.5rem;\n  border-bottom: 2px solid #e0e0e0;\n}\n\n.section-divider h4 {\n  margin: 0;\n  color: #555;\n  font-size: 0.95rem;\n  font-weight: 600;\n  text-transform: uppercase;\n  letter-spacing: 0.5px;\n}\n\n.apply-manual-btn {\n  width: 100%;\n  padding: 0.75rem;\n  background: #10b981;\n  color: white;\n  border-radius: 8px;\n  font-weight: 500;\n  font-size: 0.95rem;\n  margin-top: 1rem;\n  transition: all 0.2s;\n}\n\n.apply-manual-btn:hover {\n  background: #059669;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);\n}\n\n.instruction {\n  margin-top: 1rem;\n  padding: 0.75rem;\n  background: #e8ebfa;\n  color: #667eea;\n  border-radius: 6px;\n  font-size: 0.9rem;\n  font-weight: 500;\n  text-align: center;\n}\n\n.fields-header {\n  margin-bottom: 1rem;\n}\n\n.fields-header h3 {\n  margin-bottom: 1rem;\n  color: #333;\n  font-size: 1.1rem;\n}\n\n.save-btn {\n  width: 100%;\n  padding: 0.75rem;\n  background: #28a745;\n  color: white;\n  border-radius: 8px;\n  font-weight: 500;\n  transition: all 0.2s;\n}\n\n.save-btn:hover {\n  background: #218838;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);\n}\n\n.no-fields {\n  padding: 3rem 1.5rem;\n  text-align: center;\n  color: #999;\n}\n\n.no-fields .hint {\n  font-size: 0.875rem;\n  margin-top: 0.5rem;\n}\n\n.fields-items {\n  max-height: 500px;\n  overflow-y: auto;\n}\n\n.field-item {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  padding: 1rem;\n  border-bottom: 1px solid #f0f0f0;\n  transition: all 0.2s;\n}\n\n.field-item:hover {\n  background: #f8f9fa;\n}\n\n.field-item.editing {\n  background: #fef3c7;\n  border-left: 3px solid #f59e0b;\n}\n\n.field-info {\n  flex: 1;\n}\n\n.field-name {\n  font-weight: 600;\n  color: #333;\n  margin-bottom: 0.25rem;\n}\n\n.field-details {\n  font-size: 0.75rem;\n  color: #666;\n  font-family: 'Courier New', monospace;\n  line-height: 1.4;\n}\n\n.field-actions {\n  display: flex;\n  gap: 0.5rem;\n}\n\n.edit-btn,\n.delete-btn {\n  padding: 0.5rem;\n  background: transparent;\n  font-size: 1.1rem;\n  opacity: 0.6;\n  transition: all 0.2s;\n}\n\n.edit-btn:hover,\n.delete-btn:hover {\n  opacity: 1;\n  transform: scale(1.1);\n}\n","size_bytes":5080},"README.md":{"content":"# PDF Generator Microservice\n\nA TypeScript-based PDF Generator microservice designed for ERPNext/Frappe integration. Generate filled PDFs from templates via REST API with visual field mapping.\n\n## ‚ú® Features\n\n- üìÑ **Visual Area Selection** - Drag on PDFs to visually define field boundaries (width √ó height)\n- ‚úèÔ∏è **Rich Text Styling** - Font families, colors, bold, italic, alignment options\n- üéØ **Edit Mode** - Modify existing field mappings and redraw boundaries\n- üìè **Smart Text Handling** - Automatic word wrapping and overflow clipping\n- üîç **Zoom Controls** - 50%-400% zoom for precise field placement\n- üöÄ **REST API** - Simple `/api/generate` endpoint for PDF generation\n- üé® **Admin Interface** - React-based UI for template and mapping management\n- üì¶ **File-Based** - No database required, everything stored in folders\n- üîí **Secure** - Input validation and path traversal protection\n- ‚ö° **Fast** - Pure JavaScript PDF manipulation with pdf-lib\n\n## üöÄ Quick Start\n\n### Installation\n\n```bash\nnpm install\ncd client && npm install && cd ..\n```\n\n### Development\n\n```bash\nnpm run dev\n```\n\nThe server will start on http://localhost:5000\n\n### Production Build\n\n```bash\nnpm run build:all\nnpm start\n```\n\n## üìñ Usage\n\n### 1. Upload a Template\n\n1. Open http://localhost:5000 in your browser\n2. Click \"+ Upload PDF\" button\n3. Select your PDF template file\n\n### 2. Map Fields\n\n1. Select the template from the sidebar\n2. Go to \"Field Mapper\" tab\n3. Enter a field name (e.g., \"customer_name\") in the right panel\n4. Configure text styling (font size, family, color, bold, italic, alignment)\n5. **Drag on the PDF** to visually select the field area (width √ó height)\n   - Use zoom controls to adjust view (50%-400%)\n   - Green overlay shows selection area while dragging\n   - Text will automatically wrap within the defined area\n6. Click \"üíæ Save Mapping\" to save all fields\n\n**Edit Existing Fields:**\n1. Click the ‚úèÔ∏è edit button on any mapped field\n2. Adjust styling options in the right panel\n3. Drag on PDF to redefine the field area\n4. Save mapping when done\n\n### 3. Generate PDFs\n\n#### Via Admin Interface (Testing)\n\n1. Go to \"Test Generator\" tab\n2. Fill in sample values\n3. Click \"Generate & Download PDF\"\n\n#### Via API (Production)\n\n```javascript\nfetch('http://your-domain.com/api/generate', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    template: 'Sample_Quote.pdf',\n    data: {\n      customer_name: 'Acme Corp',\n      price: '‚Çπ1,250',\n      date: '2025-10-29'\n    }\n  })\n})\n.then(res => res.blob())\n.then(blob => {\n  const url = URL.createObjectURL(blob);\n  const link = document.createElement('a');\n  link.href = url;\n  link.download = 'output.pdf';\n  link.click();\n});\n```\n\n## üîå ERPNext/Frappe Integration\n\nAdd this to your custom script:\n\n```javascript\nfrappe.ui.form.on('Your DocType', {\n  download_pdf: function(frm) {\n    fetch('https://your-pdf-service.com/api/generate', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        template: 'Quote_Template.pdf',\n        data: {\n          customer_name: frm.doc.customer_name,\n          price: frm.doc.price,\n          date: frm.doc.date\n        }\n      })\n    })\n    .then(res => res.blob())\n    .then(blob => {\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = frm.doc.name + '.pdf';\n      link.click();\n    })\n    .catch(err => frappe.msgprint('Failed to generate PDF'));\n  }\n});\n```\n\n## üì° API Reference\n\n### POST /api/generate\n\nGenerate a filled PDF from template and JSON data.\n\n**Request:**\n```json\n{\n  \"template\": \"Template_Name.pdf\",\n  \"data\": {\n    \"field1\": \"value1\",\n    \"field2\": \"value2\"\n  }\n}\n```\n\n**Response:** PDF file (application/pdf)\n\n### GET /api/templates\n\nList all available templates.\n\n**Response:**\n```json\n[\n  { \"name\": \"Template1.pdf\", \"hasMapping\": true },\n  { \"name\": \"Template2.pdf\", \"hasMapping\": false }\n]\n```\n\n### POST /api/templates/upload\n\nUpload a new PDF template (multipart/form-data).\n\n### GET /api/templates/:name\n\nDownload a specific template.\n\n### GET /api/mappings/:name\n\nGet field mapping for a template.\n\n### POST /api/mappings/:name\n\nSave field mapping for a template.\n\n## üìÅ Project Structure\n\n```\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ server.ts          # Express API server\n‚îÇ   ‚îú‚îÄ‚îÄ pdfService.ts      # PDF manipulation service\n‚îÇ   ‚îî‚îÄ‚îÄ types.ts           # TypeScript definitions\n‚îú‚îÄ‚îÄ client/                # React admin interface\n‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ components/\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ TemplateList.tsx\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PDFMapper.tsx\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TestGenerator.tsx\n‚îÇ   ‚îî‚îÄ‚îÄ build/             # Built frontend (served by Express)\n‚îú‚îÄ‚îÄ templates/             # PDF template files\n‚îú‚îÄ‚îÄ mappings/              # JSON mapping files\n‚îî‚îÄ‚îÄ output/                # Temporary generated PDFs\n```\n\n## üõ† Technology Stack\n\n- **Backend**: Node.js 20+, Express, TypeScript\n- **PDF Library**: pdf-lib (pure JavaScript)\n- **Frontend**: React 18, Vite, PDF.js\n- **File Management**: fs-extra\n- **Upload Handling**: Multer\n\n## üîê Security\n\n- Path traversal protection with filename sanitization\n- Input validation on all endpoints\n- CORS enabled for cross-origin requests\n- Secure file upload handling\n\n## üìù Mapping JSON Format\n\nMapping files define field positions and styling in PDF coordinates:\n\n```json\n{\n  \"customer_name\": {\n    \"x\": 100,\n    \"y\": 152,\n    \"size\": 12,\n    \"align\": \"left\",\n    \"fontFamily\": \"Helvetica\",\n    \"color\": \"#000000\",\n    \"maxWidth\": 250,\n    \"maxHeight\": 40,\n    \"bold\": false,\n    \"italic\": false\n  },\n  \"description\": {\n    \"x\": 100,\n    \"y\": 250,\n    \"size\": 10,\n    \"align\": \"left\",\n    \"fontFamily\": \"Times-Roman\",\n    \"color\": \"#333333\",\n    \"maxWidth\": 400,\n    \"maxHeight\": 100,\n    \"bold\": false,\n    \"italic\": false\n  }\n}\n```\n\n**Field Properties:**\n- **x, y**: Position in points (y is baseline coordinate, 72 points = 1 inch)\n- **size**: Font size in points\n- **align**: \"left\", \"center\", or \"right\"\n- **fontFamily**: \"Helvetica\", \"Times-Roman\", or \"Courier\"\n- **color**: Hex color code (e.g., \"#000000\" for black)\n- **maxWidth**: Maximum width in points (text wraps automatically)\n- **maxHeight**: Maximum height in points (text clips if exceeded)\n- **bold**: Apply bold weight\n- **italic**: Apply italic/oblique style\n\n## üö¢ Deployment\n\n### Replit\n\nThe application is ready to deploy on Replit. Just click \"Deploy\" in the Replit interface.\n\n### Other Platforms\n\n1. Build the application: `npm run build:all`\n2. Set NODE_ENV=production\n3. Run: `npm start`\n4. Ensure port 5000 is accessible\n\n## üìÑ License\n\nMIT\n\n## ü§ù Support\n\nFor issues or questions, please open an issue in the repository.\n","size_bytes":6901},"client/src/main.tsx":{"content":"import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport './index.css';\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n","size_bytes":236},"src/pdfService.ts":{"content":"import { PDFDocument, rgb, StandardFonts, degrees } from 'pdf-lib';\nimport { TemplateMapping, FieldMapping, DrawingInsertion, Combination, CombinationInfo } from './types';\nimport fs from 'fs-extra';\nimport path from 'path';\n\nexport class PDFService {\n  private templatesDir = path.join(process.cwd(), 'templates');\n  private mappingsDir = path.join(process.cwd(), 'mappings');\n  private drawingsDir = path.join(process.cwd(), 'drawings');\n  private drawingsMappingsDir = path.join(process.cwd(), 'drawings_mappings');\n  private combinationsDir = path.join(process.cwd(), 'combinations');\n  private outputDir = path.join(process.cwd(), 'output');\n\n  constructor() {\n    fs.ensureDirSync(this.templatesDir);\n    fs.ensureDirSync(this.mappingsDir);\n    fs.ensureDirSync(this.drawingsDir);\n    fs.ensureDirSync(this.drawingsMappingsDir);\n    fs.ensureDirSync(this.combinationsDir);\n    fs.ensureDirSync(this.outputDir);\n  }\n\n  private sanitizeFilename(filename: string): string {\n    const decoded = decodeURIComponent(filename);\n    const basename = path.basename(decoded);\n    \n    if (basename !== decoded || basename.includes('..') || basename.includes('/') || basename.includes('\\\\')) {\n      throw new Error('Invalid filename: path traversal detected');\n    }\n    \n    if (!/^[a-zA-Z0-9_\\-\\. ]+$/.test(basename)) {\n      throw new Error('Invalid filename: only alphanumeric, dash, underscore, dot, and space allowed');\n    }\n    \n    return basename;\n  }\n\n  private validatePDFFilename(filename: string): string {\n    const sanitized = this.sanitizeFilename(filename);\n    \n    if (!sanitized.toLowerCase().endsWith('.pdf')) {\n      throw new Error('Invalid filename: must be a PDF file');\n    }\n    \n    return sanitized;\n  }\n\n  private validateJSONFilename(filename: string): string {\n    const sanitized = this.sanitizeFilename(filename);\n    \n    if (!sanitized.toLowerCase().endsWith('.json')) {\n      throw new Error('Invalid filename: must be a JSON file');\n    }\n    \n    return sanitized;\n  }\n\n  private hexToRgb(hex: string): { r: number; g: number; b: number } {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n      ? {\n          r: parseInt(result[1], 16) / 255,\n          g: parseInt(result[2], 16) / 255,\n          b: parseInt(result[3], 16) / 255,\n        }\n      : { r: 0, g: 0, b: 0 };\n  }\n\n  private wrapText(text: string, font: any, fontSize: number, maxWidth: number): string[] {\n    const words = text.split(' ');\n    const lines: string[] = [];\n    let currentLine = '';\n\n    for (const word of words) {\n      const testLine = currentLine ? `${currentLine} ${word}` : word;\n      const width = font.widthOfTextAtSize(testLine, fontSize);\n\n      if (width > maxWidth && currentLine) {\n        lines.push(currentLine);\n        currentLine = word;\n      } else {\n        currentLine = testLine;\n      }\n    }\n\n    if (currentLine) {\n      lines.push(currentLine);\n    }\n\n    return lines;\n  }\n\n  async generatePDF(templateName: string, data: { [key: string]: string }): Promise<Buffer> {\n    const sanitizedName = this.validatePDFFilename(templateName);\n    const templatePath = path.join(this.templatesDir, sanitizedName);\n    const mappingPath = path.join(\n      this.mappingsDir,\n      sanitizedName.replace('.pdf', '.json')\n    );\n\n    if (!await fs.pathExists(templatePath)) {\n      throw new Error(`Template not found: ${templateName}`);\n    }\n\n    if (!await fs.pathExists(mappingPath)) {\n      throw new Error(`Mapping not found for template: ${templateName}`);\n    }\n\n    const templateBytes = await fs.readFile(templatePath);\n    const mapping: TemplateMapping = await fs.readJSON(mappingPath);\n\n    const pdfDoc = await PDFDocument.load(templateBytes);\n    const pages = pdfDoc.getPages();\n    const firstPage = pages[0];\n\n    const { height } = firstPage.getSize();\n\n    for (const [fieldName, fieldMapping] of Object.entries(mapping)) {\n      const value = data[fieldName];\n      if (value === undefined || value === null) {\n        continue;\n      }\n\n      const textValue = String(value);\n      let fontSize = fieldMapping.size || 12;\n      const align = fieldMapping.align || 'left';\n      const maxWidth = fieldMapping.maxWidth || 200;\n      const colorHex = fieldMapping.color || '#000000';\n      const colorRgb = this.hexToRgb(colorHex);\n\n      const rawFamily = fieldMapping.fontFamily || 'Helvetica';\n      \n      let baseFamily = 'Helvetica';\n      let isBold = fieldMapping.bold || false;\n      let isItalic = fieldMapping.italic || false;\n      \n      if (rawFamily.includes('Times')) {\n        baseFamily = 'Times-Roman';\n        if (rawFamily.includes('Bold')) isBold = true;\n        if (rawFamily.includes('Italic')) isItalic = true;\n      } else if (rawFamily.includes('Courier')) {\n        baseFamily = 'Courier';\n        if (rawFamily.includes('Bold')) isBold = true;\n        if (rawFamily.includes('Oblique')) isItalic = true;\n      } else {\n        baseFamily = 'Helvetica';\n        if (rawFamily.includes('Bold')) isBold = true;\n        if (rawFamily.includes('Oblique')) isItalic = true;\n      }\n      \n      let finalFont: any;\n      \n      if (baseFamily === 'Helvetica') {\n        if (isBold && isItalic) finalFont = StandardFonts.HelveticaBoldOblique;\n        else if (isBold) finalFont = StandardFonts.HelveticaBold;\n        else if (isItalic) finalFont = StandardFonts.HelveticaOblique;\n        else finalFont = StandardFonts.Helvetica;\n      } else if (baseFamily === 'Times-Roman') {\n        if (isBold && isItalic) finalFont = StandardFonts.TimesRomanBoldItalic;\n        else if (isBold) finalFont = StandardFonts.TimesRomanBold;\n        else if (isItalic) finalFont = StandardFonts.TimesRomanItalic;\n        else finalFont = StandardFonts.TimesRoman;\n      } else if (baseFamily === 'Courier') {\n        if (isBold && isItalic) finalFont = StandardFonts.CourierBoldOblique;\n        else if (isBold) finalFont = StandardFonts.CourierBold;\n        else if (isItalic) finalFont = StandardFonts.CourierOblique;\n        else finalFont = StandardFonts.Courier;\n      } else {\n        finalFont = StandardFonts.Helvetica;\n      }\n\n      const font = await pdfDoc.embedFont(finalFont);\n\n      const maxHeight = fieldMapping.maxHeight || 1000;\n      const lineHeight = fontSize + 2;\n      const textWidth = font.widthOfTextAtSize(textValue, fontSize);\n      const baselineY = fieldMapping.y + fontSize;\n      \n      if (textWidth > maxWidth) {\n        const lines = this.wrapText(textValue, font, fontSize, maxWidth);\n        \n        let currentY = baselineY;\n        for (const line of lines) {\n          const lineOffset = currentY - baselineY;\n          \n          if (lineOffset + lineHeight > maxHeight) {\n            break;\n          }\n          \n          let x = fieldMapping.x;\n          const y = height - currentY;\n\n          const lineWidth = font.widthOfTextAtSize(line, fontSize);\n          \n          if (align === 'center') {\n            x = x + (maxWidth - lineWidth) / 2;\n          } else if (align === 'right') {\n            x = x + maxWidth - lineWidth;\n          }\n\n          firstPage.drawText(line, {\n            x,\n            y,\n            size: fontSize,\n            font: font,\n            color: rgb(colorRgb.r, colorRgb.g, colorRgb.b),\n          });\n\n          currentY += lineHeight;\n        }\n      } else {\n        let x = fieldMapping.x;\n        const y = height - baselineY;\n\n        if (align === 'center') {\n          x = x + (maxWidth - textWidth) / 2;\n        } else if (align === 'right') {\n          x = x + maxWidth - textWidth;\n        }\n\n        firstPage.drawText(textValue, {\n          x,\n          y,\n          size: fontSize,\n          font: font,\n          color: rgb(colorRgb.r, colorRgb.g, colorRgb.b),\n        });\n      }\n    }\n\n    const pdfBytes = await pdfDoc.save();\n    return Buffer.from(pdfBytes);\n  }\n\n  async listTemplates(): Promise<{ name: string; hasMapping: boolean }[]> {\n    const files = await fs.readdir(this.templatesDir);\n    const pdfFiles = files.filter(f => f.endsWith('.pdf'));\n\n    const templates = await Promise.all(\n      pdfFiles.map(async (name) => {\n        const mappingPath = path.join(\n          this.mappingsDir,\n          name.replace('.pdf', '.json')\n        );\n        const hasMapping = await fs.pathExists(mappingPath);\n        return { name, hasMapping };\n      })\n    );\n\n    return templates;\n  }\n\n  async getMapping(templateName: string): Promise<TemplateMapping | null> {\n    const sanitizedName = this.validatePDFFilename(templateName);\n    const mappingPath = path.join(\n      this.mappingsDir,\n      sanitizedName.replace('.pdf', '.json')\n    );\n\n    if (!await fs.pathExists(mappingPath)) {\n      return null;\n    }\n\n    return await fs.readJSON(mappingPath);\n  }\n\n  async saveMapping(templateName: string, mapping: TemplateMapping): Promise<void> {\n    const sanitizedName = this.validatePDFFilename(templateName);\n    const mappingPath = path.join(\n      this.mappingsDir,\n      sanitizedName.replace('.pdf', '.json')\n    );\n\n    await fs.writeJSON(mappingPath, mapping, { spaces: 2 });\n  }\n\n  async getTemplate(templateName: string): Promise<Buffer> {\n    const sanitizedName = this.validatePDFFilename(templateName);\n    const templatePath = path.join(this.templatesDir, sanitizedName);\n\n    if (!await fs.pathExists(templatePath)) {\n      throw new Error(`Template not found: ${templateName}`);\n    }\n\n    return await fs.readFile(templatePath);\n  }\n\n  async saveTemplate(templateName: string, buffer: Buffer): Promise<void> {\n    const sanitizedName = this.validatePDFFilename(templateName);\n    const templatePath = path.join(this.templatesDir, sanitizedName);\n    await fs.writeFile(templatePath, buffer);\n  }\n\n  async deleteTemplate(templateName: string): Promise<void> {\n    const sanitizedName = this.validatePDFFilename(templateName);\n    const templatePath = path.join(this.templatesDir, sanitizedName);\n    const mappingPath = path.join(\n      this.mappingsDir,\n      sanitizedName.replace('.pdf', '.json')\n    );\n\n    if (await fs.pathExists(templatePath)) {\n      await fs.remove(templatePath);\n    }\n\n    if (await fs.pathExists(mappingPath)) {\n      await fs.remove(mappingPath);\n    }\n  }\n\n  async listDrawings(): Promise<{ name: string; type: 'pdf' | 'image' | 'svg'; hasMapping: boolean }[]> {\n    const files = await fs.readdir(this.drawingsDir);\n    const drawings: { name: string; type: 'pdf' | 'image' | 'svg'; hasMapping: boolean }[] = [];\n\n    for (const file of files) {\n      const lowerFile = file.toLowerCase();\n      let type: 'pdf' | 'image' | 'svg' = 'image';\n      \n      if (lowerFile.endsWith('.pdf')) {\n        type = 'pdf';\n      } else if (lowerFile.endsWith('.svg')) {\n        type = 'svg';\n      }\n\n      const mappingPath = path.join(\n        this.drawingsMappingsDir,\n        file.replace(/\\.(pdf|png|jpg|jpeg|gif|bmp|svg)$/i, '.json')\n      );\n      const hasMapping = await fs.pathExists(mappingPath);\n\n      drawings.push({ name: file, type, hasMapping });\n    }\n\n    return drawings;\n  }\n\n  async getDrawing(drawingName: string): Promise<{ buffer: Buffer; contentType: string }> {\n    const sanitizedName = this.sanitizeFilename(drawingName);\n    const drawingPath = path.join(this.drawingsDir, sanitizedName);\n\n    if (!await fs.pathExists(drawingPath)) {\n      throw new Error(`Drawing not found: ${drawingName}`);\n    }\n\n    const buffer = await fs.readFile(drawingPath);\n    const lowerName = sanitizedName.toLowerCase();\n    \n    let contentType = 'application/octet-stream';\n    if (lowerName.endsWith('.pdf')) {\n      contentType = 'application/pdf';\n    } else if (lowerName.endsWith('.svg')) {\n      contentType = 'image/svg+xml';\n    } else if (lowerName.endsWith('.png')) {\n      contentType = 'image/png';\n    } else if (lowerName.endsWith('.jpg') || lowerName.endsWith('.jpeg')) {\n      contentType = 'image/jpeg';\n    } else if (lowerName.endsWith('.gif')) {\n      contentType = 'image/gif';\n    }\n\n    return { buffer, contentType };\n  }\n\n  async saveDrawing(drawingName: string, buffer: Buffer): Promise<void> {\n    const sanitizedName = this.sanitizeFilename(drawingName);\n    const drawingPath = path.join(this.drawingsDir, sanitizedName);\n    await fs.writeFile(drawingPath, buffer);\n  }\n\n  async deleteDrawing(drawingName: string): Promise<void> {\n    const sanitizedName = this.sanitizeFilename(drawingName);\n    const drawingPath = path.join(this.drawingsDir, sanitizedName);\n    const mappingPath = path.join(\n      this.drawingsMappingsDir,\n      sanitizedName.replace(/\\.(pdf|png|jpg|jpeg|gif|bmp|svg)$/i, '.json')\n    );\n\n    if (await fs.pathExists(drawingPath)) {\n      await fs.remove(drawingPath);\n    }\n\n    if (await fs.pathExists(mappingPath)) {\n      await fs.remove(mappingPath);\n    }\n  }\n\n  async getDrawingMapping(drawingName: string): Promise<TemplateMapping | null> {\n    const sanitizedName = this.sanitizeFilename(drawingName);\n    const mappingPath = path.join(\n      this.drawingsMappingsDir,\n      sanitizedName.replace(/\\.(pdf|png|jpg|jpeg|gif|bmp|svg)$/i, '.json')\n    );\n\n    if (!await fs.pathExists(mappingPath)) {\n      return null;\n    }\n\n    return await fs.readJSON(mappingPath);\n  }\n\n  async saveDrawingMapping(drawingName: string, mapping: TemplateMapping): Promise<void> {\n    const sanitizedName = this.sanitizeFilename(drawingName);\n    const mappingPath = path.join(\n      this.drawingsMappingsDir,\n      sanitizedName.replace(/\\.(pdf|png|jpg|jpeg|gif|bmp|svg)$/i, '.json')\n    );\n\n    await fs.writeJSON(mappingPath, mapping, { spaces: 2 });\n  }\n\n  async renameDrawing(oldName: string, newName: string): Promise<void> {\n    const sanitizedOldName = this.sanitizeFilename(oldName);\n    const sanitizedNewName = this.sanitizeFilename(newName);\n\n    const oldExtension = path.extname(sanitizedOldName);\n    const newExtension = path.extname(sanitizedNewName);\n\n    if (oldExtension.toLowerCase() !== newExtension.toLowerCase()) {\n      throw new Error('Cannot change file extension when renaming');\n    }\n\n    const oldDrawingPath = path.join(this.drawingsDir, sanitizedOldName);\n    const newDrawingPath = path.join(this.drawingsDir, sanitizedNewName);\n\n    if (!await fs.pathExists(oldDrawingPath)) {\n      throw new Error(`Drawing not found: ${oldName}`);\n    }\n\n    if (await fs.pathExists(newDrawingPath)) {\n      throw new Error(`Drawing already exists with name: ${newName}`);\n    }\n\n    await fs.rename(oldDrawingPath, newDrawingPath);\n\n    const oldMappingPath = path.join(\n      this.drawingsMappingsDir,\n      sanitizedOldName.replace(/\\.(pdf|png|jpg|jpeg|gif|bmp|svg)$/i, '.json')\n    );\n    const newMappingPath = path.join(\n      this.drawingsMappingsDir,\n      sanitizedNewName.replace(/\\.(pdf|png|jpg|jpeg|gif|bmp|svg)$/i, '.json')\n    );\n\n    if (await fs.pathExists(oldMappingPath)) {\n      await fs.rename(oldMappingPath, newMappingPath);\n    }\n  }\n\n  async listCombinations(): Promise<CombinationInfo[]> {\n    const files = await fs.readdir(this.combinationsDir);\n    const jsonFiles = files.filter(f => f.endsWith('.json'));\n    return jsonFiles.map(name => ({ name: name.replace('.json', '') }));\n  }\n\n  async getCombination(combinationName: string): Promise<Combination | null> {\n    const sanitizedName = this.sanitizeFilename(combinationName + '.json');\n    const combinationPath = path.join(this.combinationsDir, sanitizedName);\n\n    if (!await fs.pathExists(combinationPath)) {\n      return null;\n    }\n\n    return await fs.readJSON(combinationPath);\n  }\n\n  async saveCombination(combinationName: string, combination: Combination): Promise<void> {\n    const sanitizedName = this.sanitizeFilename(combinationName + '.json');\n    const combinationPath = path.join(this.combinationsDir, sanitizedName);\n    await fs.writeJSON(combinationPath, combination, { spaces: 2 });\n  }\n\n  async deleteCombination(combinationName: string): Promise<void> {\n    const sanitizedName = this.sanitizeFilename(combinationName + '.json');\n    const combinationPath = path.join(this.combinationsDir, sanitizedName);\n\n    if (await fs.pathExists(combinationPath)) {\n      await fs.remove(combinationPath);\n    }\n  }\n\n  async generateWithCombination(\n    combinationName: string,\n    templateData: { [key: string]: string },\n    drawingsData: { [drawingName: string]: { [key: string]: string } }\n  ): Promise<Buffer> {\n    const combination = await this.getCombination(combinationName);\n    \n    if (!combination) {\n      throw new Error(`Combination not found: ${combinationName}`);\n    }\n\n    const templateBuffer = await this.getTemplate(combination.templateName);\n    const templatePdfDoc = await PDFDocument.load(templateBuffer);\n    const templateMapping = await this.getMapping(combination.templateName);\n    const firstPage = templatePdfDoc.getPages()[0];\n    const { height } = firstPage.getSize();\n\n    if (templateMapping) {\n      for (const [fieldName, fieldMapping] of Object.entries(templateMapping)) {\n        const textValue = templateData[fieldName];\n        if (!textValue) continue;\n\n        const fontSize = fieldMapping.size || 12;\n        const maxWidth = fieldMapping.maxWidth || 200;\n        const align = fieldMapping.align || 'left';\n        const colorHex = fieldMapping.color || '#000000';\n        const colorRgb = this.hexToRgb(colorHex);\n        const fontFamily = fieldMapping.fontFamily || 'Helvetica';\n        const isBold = fieldMapping.bold || false;\n        const isItalic = fieldMapping.italic || false;\n\n        const baseFamily = fontFamily.replace(/-Bold|-Oblique|-BoldOblique|-Italic|-BoldItalic/gi, '');\n\n        let finalFont: any;\n        if (baseFamily === 'Helvetica') {\n          if (isBold && isItalic) finalFont = StandardFonts.HelveticaBoldOblique;\n          else if (isBold) finalFont = StandardFonts.HelveticaBold;\n          else if (isItalic) finalFont = StandardFonts.HelveticaOblique;\n          else finalFont = StandardFonts.Helvetica;\n        } else if (baseFamily === 'Times-Roman') {\n          if (isBold && isItalic) finalFont = StandardFonts.TimesRomanBoldItalic;\n          else if (isBold) finalFont = StandardFonts.TimesRomanBold;\n          else if (isItalic) finalFont = StandardFonts.TimesRomanItalic;\n          else finalFont = StandardFonts.TimesRoman;\n        } else if (baseFamily === 'Courier') {\n          if (isBold && isItalic) finalFont = StandardFonts.CourierBoldOblique;\n          else if (isBold) finalFont = StandardFonts.CourierBold;\n          else if (isItalic) finalFont = StandardFonts.CourierOblique;\n          else finalFont = StandardFonts.Courier;\n        } else {\n          finalFont = StandardFonts.Helvetica;\n        }\n\n        const font = await templatePdfDoc.embedFont(finalFont);\n        const maxHeight = fieldMapping.maxHeight || 1000;\n        const lineHeight = fontSize + 2;\n        const textWidth = font.widthOfTextAtSize(textValue, fontSize);\n        const baselineY = fieldMapping.y + fontSize;\n\n        if (textWidth > maxWidth) {\n          const lines = this.wrapText(textValue, font, fontSize, maxWidth);\n          let currentY = baselineY;\n          for (const line of lines) {\n            const lineOffset = currentY - baselineY;\n            if (lineOffset + lineHeight > maxHeight) break;\n\n            let x = fieldMapping.x;\n            const y = height - currentY;\n            const lineWidth = font.widthOfTextAtSize(line, fontSize);\n\n            if (align === 'center') x = x + (maxWidth - lineWidth) / 2;\n            else if (align === 'right') x = x + maxWidth - lineWidth;\n\n            firstPage.drawText(line, {\n              x,\n              y,\n              size: fontSize,\n              font: font,\n              color: rgb(colorRgb.r, colorRgb.g, colorRgb.b),\n            });\n            currentY += lineHeight;\n          }\n        } else {\n          let x = fieldMapping.x;\n          const y = height - baselineY;\n\n          if (align === 'center') x = x + (maxWidth - textWidth) / 2;\n          else if (align === 'right') x = x + maxWidth - textWidth;\n\n          firstPage.drawText(textValue, {\n            x,\n            y,\n            size: fontSize,\n            font: font,\n            color: rgb(colorRgb.r, colorRgb.g, colorRgb.b),\n          });\n        }\n      }\n    }\n\n    for (const placement of combination.drawingPlacements) {\n      if (placement.conditionField && placement.conditionValue) {\n        const conditionFieldValue = templateData[placement.conditionField];\n        if (conditionFieldValue !== placement.conditionValue) {\n          continue;\n        }\n      }\n\n      const drawingName = placement.drawingName;\n      const drawingBuffer = await this.getDrawing(drawingName);\n      const drawingMapping = await this.getDrawingMapping(drawingName);\n      const drawingData = drawingsData[drawingName] || {};\n      const drawingExt = path.extname(drawingName).toLowerCase();\n\n      if (drawingExt === '.pdf') {\n        const drawingPdfDoc = await PDFDocument.load(drawingBuffer.buffer);\n\n        if (drawingMapping) {\n          const drawingPages = drawingPdfDoc.getPages();\n          const drawingFirstPage = drawingPages[0];\n          const { height: drawingHeight } = drawingFirstPage.getSize();\n\n          for (const [fieldName, fieldMapping] of Object.entries(drawingMapping)) {\n            const textValue = drawingData[fieldName];\n            if (!textValue) continue;\n\n            const fontSize = fieldMapping.size || 12;\n            const maxWidth = fieldMapping.maxWidth || 200;\n            const align = fieldMapping.align || 'left';\n            const colorHex = fieldMapping.color || '#000000';\n            const colorRgb = this.hexToRgb(colorHex);\n            const fontFamily = fieldMapping.fontFamily || 'Helvetica';\n            const isBold = fieldMapping.bold || false;\n            const isItalic = fieldMapping.italic || false;\n\n            const baseFamily = fontFamily.replace(/-Bold|-Oblique|-BoldOblique|-Italic|-BoldItalic/gi, '');\n\n            let finalFont: any;\n            if (baseFamily === 'Helvetica') {\n              if (isBold && isItalic) finalFont = StandardFonts.HelveticaBoldOblique;\n              else if (isBold) finalFont = StandardFonts.HelveticaBold;\n              else if (isItalic) finalFont = StandardFonts.HelveticaOblique;\n              else finalFont = StandardFonts.Helvetica;\n            } else if (baseFamily === 'Times-Roman') {\n              if (isBold && isItalic) finalFont = StandardFonts.TimesRomanBoldItalic;\n              else if (isBold) finalFont = StandardFonts.TimesRomanBold;\n              else if (isItalic) finalFont = StandardFonts.TimesRomanItalic;\n              else finalFont = StandardFonts.TimesRoman;\n            } else if (baseFamily === 'Courier') {\n              if (isBold && isItalic) finalFont = StandardFonts.CourierBoldOblique;\n              else if (isBold) finalFont = StandardFonts.CourierBold;\n              else if (isItalic) finalFont = StandardFonts.CourierOblique;\n              else finalFont = StandardFonts.Courier;\n            } else {\n              finalFont = StandardFonts.Helvetica;\n            }\n\n            const font = await drawingPdfDoc.embedFont(finalFont);\n            const maxHeight = fieldMapping.maxHeight || 1000;\n            const lineHeight = fontSize + 2;\n            const textWidth = font.widthOfTextAtSize(textValue, fontSize);\n            const baselineY = fieldMapping.y + fontSize;\n\n            if (textWidth > maxWidth) {\n              const lines = this.wrapText(textValue, font, fontSize, maxWidth);\n              let currentY = baselineY;\n              for (const line of lines) {\n                const lineOffset = currentY - baselineY;\n                if (lineOffset + lineHeight > maxHeight) break;\n\n                let x = fieldMapping.x;\n                const y = drawingHeight - currentY;\n                const lineWidth = font.widthOfTextAtSize(line, fontSize);\n\n                if (align === 'center') x = x + (maxWidth - lineWidth) / 2;\n                else if (align === 'right') x = x + maxWidth - lineWidth;\n\n                drawingFirstPage.drawText(line, {\n                  x,\n                  y,\n                  size: fontSize,\n                  font: font,\n                  color: rgb(colorRgb.r, colorRgb.g, colorRgb.b),\n                });\n                currentY += lineHeight;\n              }\n            } else {\n              let x = fieldMapping.x;\n              const y = drawingHeight - baselineY;\n\n              if (align === 'center') x = x + (maxWidth - textWidth) / 2;\n              else if (align === 'right') x = x + maxWidth - textWidth;\n\n              drawingFirstPage.drawText(textValue, {\n                x,\n                y,\n                size: fontSize,\n                font: font,\n                color: rgb(colorRgb.r, colorRgb.g, colorRgb.b),\n              });\n            }\n          }\n        }\n\n        const [embeddedPage] = await templatePdfDoc.embedPdf(drawingPdfDoc, [0]);\n        \n        const drawingWidth = embeddedPage.width;\n        const drawingHeight = embeddedPage.height;\n        const drawingAspectRatio = drawingWidth / drawingHeight;\n        \n        const placementAspectRatio = placement.width / placement.height;\n        let finalWidth = placement.width;\n        let finalHeight = placement.height;\n        let offsetX = 0;\n        let offsetY = 0;\n        \n        if (drawingAspectRatio > placementAspectRatio) {\n          finalHeight = placement.width / drawingAspectRatio;\n          offsetY = (placement.height - finalHeight) / 2;\n        } else {\n          finalWidth = placement.height * drawingAspectRatio;\n          offsetX = (placement.width - finalWidth) / 2;\n        }\n        \n        const rotation = placement.rotation || 0;\n        let drawX = placement.x + offsetX;\n        let drawY = height - placement.y - placement.height + offsetY;\n        \n        if (rotation !== 0) {\n          const rad = (rotation * Math.PI) / 180;\n          const cos = Math.cos(rad);\n          const sin = Math.sin(rad);\n          \n          const centerX = drawX + finalWidth / 2;\n          const centerY = drawY + finalHeight / 2;\n          \n          const dx = drawX - centerX;\n          const dy = drawY - centerY;\n          \n          drawX = centerX + dx * cos - dy * sin;\n          drawY = centerY + dx * sin + dy * cos;\n        }\n        \n        firstPage.drawPage(embeddedPage, {\n          x: drawX,\n          y: drawY,\n          width: finalWidth,\n          height: finalHeight,\n          rotate: degrees(rotation),\n        });\n      } else if (['.png', '.jpg', '.jpeg'].includes(drawingExt)) {\n        let image;\n        if (drawingExt === '.png') {\n          image = await templatePdfDoc.embedPng(drawingBuffer.buffer);\n        } else {\n          image = await templatePdfDoc.embedJpg(drawingBuffer.buffer);\n        }\n\n        const imageWidth = image.width;\n        const imageHeight = image.height;\n        const imageAspectRatio = imageWidth / imageHeight;\n        \n        const placementAspectRatio = placement.width / placement.height;\n        let finalWidth = placement.width;\n        let finalHeight = placement.height;\n        let offsetX = 0;\n        let offsetY = 0;\n        \n        if (imageAspectRatio > placementAspectRatio) {\n          finalHeight = placement.width / imageAspectRatio;\n          offsetY = (placement.height - finalHeight) / 2;\n        } else {\n          finalWidth = placement.height * imageAspectRatio;\n          offsetX = (placement.width - finalWidth) / 2;\n        }\n\n        const rotation = placement.rotation || 0;\n        let drawX = placement.x + offsetX;\n        let drawY = height - placement.y - placement.height + offsetY;\n        \n        if (rotation !== 0) {\n          const rad = (rotation * Math.PI) / 180;\n          const cos = Math.cos(rad);\n          const sin = Math.sin(rad);\n          \n          const centerX = drawX + finalWidth / 2;\n          const centerY = drawY + finalHeight / 2;\n          \n          const dx = drawX - centerX;\n          const dy = drawY - centerY;\n          \n          drawX = centerX + dx * cos - dy * sin;\n          drawY = centerY + dx * sin + dy * cos;\n        }\n        \n        firstPage.drawImage(image, {\n          x: drawX,\n          y: drawY,\n          width: finalWidth,\n          height: finalHeight,\n          rotate: degrees(rotation),\n        });\n      }\n    }\n\n    const pdfBytes = await templatePdfDoc.save();\n    return Buffer.from(pdfBytes);\n  }\n}\n","size_bytes":28403},"client/src/components/DrawingMapper.tsx":{"content":"import { useState, useEffect } from 'react';\nimport PDFMapper from './PDFMapper';\n\ninterface Props {\n  drawingName: string;\n  onMappingSaved: () => void;\n}\n\nfunction DrawingMapper({ drawingName, onMappingSaved }: Props) {\n  const [drawingType, setDrawingType] = useState<'pdf' | 'image' | 'svg'>('pdf');\n\n  useEffect(() => {\n    const fetchDrawingType = async () => {\n      try {\n        const response = await fetch('/api/drawings');\n        const drawings = await response.json();\n        const drawing = drawings.find((d: any) => d.name === drawingName);\n        if (drawing) {\n          setDrawingType(drawing.type);\n        }\n      } catch (error) {\n        console.error('Failed to fetch drawing type:', error);\n      }\n    };\n\n    fetchDrawingType();\n  }, [drawingName]);\n\n  if (drawingType !== 'pdf') {\n    return (\n      <div style={{ padding: '2rem', textAlign: 'center' }}>\n        <h2>Drawing Field Mapping</h2>\n        <p style={{ color: '#666', marginTop: '1rem' }}>\n          Field mapping is currently only supported for PDF drawings.\n        </p>\n        <p style={{ color: '#666', marginTop: '0.5rem' }}>\n          Image-based drawings ({drawingType.toUpperCase()}) can be placed in templates but cannot have field mappings.\n        </p>\n        <p style={{ color: '#999', fontSize: '0.9rem', marginTop: '1.5rem' }}>\n          Convert your drawing to PDF format to enable field mapping.\n        </p>\n      </div>\n    );\n  }\n\n  return (\n    <PDFMapper\n      templateName={drawingName}\n      onMappingSaved={onMappingSaved}\n      isDrawing={true}\n    />\n  );\n}\n\nexport default DrawingMapper;\n","size_bytes":1608},"client/src/components/CombinationsManager.css":{"content":".combinations-manager {\n  display: flex;\n  height: 100%;\n  background: #f8f9fa;\n}\n\n.combinations-sidebar {\n  width: 300px;\n  background: white;\n  border-right: 2px solid #e0e0e0;\n  padding: 1.5rem;\n  overflow-y: auto;\n  flex-shrink: 0;\n  transition: all 0.3s ease;\n}\n\n.combinations-sidebar.collapsed {\n  width: 0;\n  padding: 0;\n  border: none;\n  overflow: hidden;\n}\n\n.combinations-sidebar h2 {\n  font-size: 1.5rem;\n  color: #333;\n  margin-bottom: 0.5rem;\n}\n\n.combinations-subtitle {\n  color: #666;\n  margin-bottom: 1.5rem;\n  font-size: 0.9rem;\n}\n\n.create-combination-btn {\n  width: 100%;\n  padding: 0.75rem 1.5rem;\n  background: #667eea;\n  color: white;\n  border-radius: 8px;\n  font-weight: 500;\n  transition: all 0.2s;\n  margin-bottom: 1.5rem;\n}\n\n.create-combination-btn:hover {\n  background: #5568d3;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);\n}\n\n.combinations-list {\n  display: flex;\n  flex-direction: column;\n  gap: 0.5rem;\n}\n\n.no-combinations {\n  padding: 2rem 1rem;\n  text-align: center;\n  color: #999;\n}\n\n.no-combinations .hint {\n  font-size: 0.875rem;\n  margin-top: 0.5rem;\n}\n\n.combination-item {\n  display: flex;\n  align-items: center;\n  gap: 0.75rem;\n  padding: 0.75rem;\n  background: #f8f9fa;\n  border-radius: 8px;\n  cursor: pointer;\n  transition: all 0.2s;\n  border: 2px solid transparent;\n}\n\n.combination-item:hover {\n  background: #e8ebfa;\n  border-color: #667eea;\n}\n\n.combination-item.selected {\n  background: #667eea;\n  color: white;\n  border-color: #667eea;\n}\n\n.combination-icon {\n  font-size: 1.5rem;\n}\n\n.combination-name {\n  font-weight: 500;\n  flex: 1;\n}\n\n.combinations-editor {\n  flex: 1;\n  padding: 1.5rem 2rem 2rem 2rem;\n  overflow-y: auto;\n  display: flex;\n  flex-direction: column;\n  min-height: 0;\n}\n\n.no-selection {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  height: 100%;\n  color: #999;\n}\n\n.no-selection h2 {\n  color: #666;\n  font-size: 1.5rem;\n  margin-bottom: 0.5rem;\n}\n\n.editor-content {\n  max-width: 100%;\n  margin: 0 auto;\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n}\n\n.editor-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 1.5rem;\n  padding-bottom: 1rem;\n  border-bottom: 2px solid #e0e0e0;\n  flex-shrink: 0;\n}\n\n.editor-header h2 {\n  font-size: 1.75rem;\n  color: #333;\n}\n\n.editor-actions {\n  display: flex;\n  gap: 0.75rem;\n  align-items: center;\n}\n\n.save-btn,\n.delete-btn {\n  padding: 0.625rem 1.25rem;\n  border-radius: 6px;\n  font-weight: 500;\n  font-size: 0.95rem;\n  transition: all 0.2s;\n}\n\n.save-btn {\n  background: #28a745;\n  color: white;\n}\n\n.save-btn:hover {\n  background: #218838;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);\n}\n\n.delete-btn {\n  background: #dc3545;\n  color: white;\n}\n\n.delete-btn:hover {\n  background: #c82333;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);\n}\n\n.form-group {\n  margin-bottom: 2rem;\n}\n\n.form-group label {\n  display: block;\n  font-weight: 600;\n  color: #333;\n  margin-bottom: 0.5rem;\n  font-size: 1.1rem;\n}\n\n.combination-name-input,\n.template-select {\n  width: 100%;\n  padding: 0.75rem;\n  border: 2px solid #e0e0e0;\n  border-radius: 8px;\n  font-size: 1rem;\n  transition: border-color 0.2s;\n}\n\n.combination-name-input:focus,\n.template-select:focus {\n  outline: none;\n  border-color: #667eea;\n}\n\n.section-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 1rem;\n}\n\n.add-drawing-btn {\n  padding: 0.5rem 1rem;\n  background: #667eea;\n  color: white;\n  border-radius: 6px;\n  font-size: 0.9rem;\n  font-weight: 500;\n  transition: all 0.2s;\n}\n\n.add-drawing-btn:hover {\n  background: #5568d3;\n  transform: translateY(-1px);\n}\n\n.no-placements {\n  padding: 2rem 1rem;\n  text-align: center;\n  color: #999;\n  background: white;\n  border-radius: 8px;\n  border: 2px dashed #e0e0e0;\n}\n\n.no-placements .hint {\n  font-size: 0.875rem;\n  margin-top: 0.5rem;\n}\n\n.placements-list {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n}\n\n.placement-card {\n  background: white;\n  border: 2px solid #e0e0e0;\n  border-radius: 12px;\n  padding: 1rem;\n  transition: box-shadow 0.2s;\n}\n\n.placement-card:hover {\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n}\n\n.placement-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 1rem;\n  padding-bottom: 0.75rem;\n  border-bottom: 1px solid #f0f0f0;\n}\n\n.placement-index {\n  font-weight: 600;\n  color: #667eea;\n  font-size: 1.1rem;\n}\n\n.remove-placement-btn {\n  padding: 0.25rem 0.5rem;\n  background: #fee;\n  color: #dc3545;\n  border-radius: 4px;\n  font-size: 1.2rem;\n  line-height: 1;\n  transition: all 0.2s;\n}\n\n.remove-placement-btn:hover {\n  background: #dc3545;\n  color: white;\n  transform: scale(1.1);\n}\n\n.placement-form {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n}\n\n.placement-field {\n  display: flex;\n  flex-direction: column;\n  gap: 0.25rem;\n}\n\n.placement-field label {\n  font-size: 0.875rem;\n  font-weight: 500;\n  color: #666;\n}\n\n.placement-field select,\n.placement-field input {\n  padding: 0.5rem;\n  border: 1px solid #e0e0e0;\n  border-radius: 6px;\n  font-size: 0.95rem;\n}\n\n.placement-field select:focus,\n.placement-field input:focus {\n  outline: none;\n  border-color: #667eea;\n}\n\n.placement-coords {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  gap: 0.75rem;\n}\n\n.placement-coords .placement-field input {\n  width: 100%;\n}\n\n.view-mode-tabs {\n  display: flex;\n  gap: 0.5rem;\n}\n\n.mode-tab {\n  padding: 0.625rem 1rem;\n  border-radius: 6px;\n  font-weight: 500;\n  background: #f0f0f0;\n  color: #666;\n  transition: all 0.2s;\n  font-size: 0.9rem;\n}\n\n.mode-tab:hover {\n  background: #e0e0e0;\n}\n\n.mode-tab.active {\n  background: #667eea;\n  color: white;\n}\n\n.test-layout {\n  display: flex;\n  flex: 1;\n  margin-top: 0;\n  min-height: 0;\n}\n\n.test-sidebar {\n  width: 40%;\n  min-width: 550px;\n  max-width: 800px;\n  border-right: 1px solid #e0e0e0;\n  display: flex;\n  flex-direction: column;\n  overflow-y: auto;\n  background: white;\n  border-radius: 8px 0 0 8px;\n}\n\n.test-header {\n  padding: 1.5rem;\n  border-bottom: 1px solid #e0e0e0;\n  background: #fafafa;\n}\n\n.test-header h3 {\n  margin: 0 0 0.5rem 0;\n  color: #333;\n  font-size: 1.2rem;\n}\n\n.test-header p {\n  margin: 0;\n  color: #666;\n  font-size: 0.9rem;\n}\n\n.test-form {\n  flex: 1;\n  padding: 1.5rem;\n  overflow-y: auto;\n}\n\n.test-section {\n  margin-bottom: 2rem;\n  padding-bottom: 1.5rem;\n  border-bottom: 2px solid #f0f0f0;\n}\n\n.test-section:last-child {\n  border-bottom: none;\n}\n\n.test-section h4 {\n  margin: 0 0 1rem 0;\n  color: #667eea;\n  font-size: 1rem;\n  font-weight: 600;\n}\n\n.test-form .form-group {\n  margin-bottom: 1.25rem;\n}\n\n.test-form .form-group label {\n  font-weight: 500;\n  color: #444;\n  font-size: 0.9rem;\n}\n\n.test-form .form-group input {\n  padding: 0.625rem;\n  border: 1px solid #ddd;\n  border-radius: 6px;\n  font-size: 0.95rem;\n  transition: border-color 0.2s;\n}\n\n.test-form .form-group input:focus {\n  outline: none;\n  border-color: #667eea;\n  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);\n}\n\n.test-actions {\n  padding: 1.5rem;\n  border-top: 1px solid #e0e0e0;\n  display: flex;\n  flex-direction: column;\n  gap: 0.75rem;\n  background: #fafafa;\n}\n\n.generate-btn,\n.download-btn {\n  width: 100%;\n  padding: 0.875rem;\n  font-weight: 500;\n  font-size: 1rem;\n  border-radius: 8px;\n  transition: all 0.2s;\n  cursor: pointer;\n}\n\n.generate-btn {\n  background: #667eea;\n  color: white;\n}\n\n.generate-btn:hover:not(:disabled) {\n  background: #5568d3;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);\n}\n\n.generate-btn:disabled {\n  opacity: 0.6;\n  cursor: not-allowed;\n}\n\n.download-btn {\n  background: #28a745;\n  color: white;\n}\n\n.download-btn:hover {\n  background: #218838;\n  transform: translateY(-1px);\n  box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);\n}\n\n.test-preview {\n  flex: 1;\n  background: #1a1a1a;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  border-radius: 0 8px 8px 0;\n}\n\n.pdf-preview-container {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n}\n\n.preview-header {\n  padding: 1rem 1.5rem;\n  background: rgba(255, 255, 255, 0.1);\n  border-bottom: 1px solid rgba(255, 255, 255, 0.1);\n}\n\n.preview-header h4 {\n  margin: 0 0 0.25rem 0;\n  color: white;\n  font-size: 1.1rem;\n}\n\n.preview-header p {\n  margin: 0;\n  color: rgba(255, 255, 255, 0.6);\n  font-size: 0.875rem;\n}\n\n.pdf-preview-frame {\n  flex: 1;\n  width: 100%;\n  border: none;\n  background: white;\n}\n\n.no-preview {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.no-preview-content {\n  text-align: center;\n  padding: 2rem;\n  max-width: 450px;\n}\n\n.preview-icon {\n  font-size: 3rem;\n  display: block;\n  margin-bottom: 1rem;\n  opacity: 0.2;\n}\n\n.no-preview-content h3 {\n  color: rgba(255, 255, 255, 0.85);\n  margin: 0 0 0.75rem 0;\n  font-size: 1.25rem;\n  font-weight: 500;\n}\n\n.no-preview-content p {\n  color: rgba(255, 255, 255, 0.5);\n  font-size: 0.9rem;\n  margin: 0;\n  line-height: 1.6;\n}\n\n.visual-placement-container {\n  margin-top: 1.5rem;\n}\n\n.visual-placement-container > label {\n  display: block;\n  margin-bottom: 0.75rem;\n  font-size: 1.1rem;\n}\n\n.visual-placement-container .visual-placement-editor {\n  height: calc(100vh - 200px);\n  min-height: 600px;\n  border: 2px solid #e0e0e0;\n}\n","size_bytes":9372}},"version":2}